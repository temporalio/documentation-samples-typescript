"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNamespace = exports.waitOnNamespace = void 0;
const time_1 = require("@temporalio/common/lib/time");
// Starting with 1.20, we should no longer need to wait on namespace
// TODO: Remove all of this once we are confident that this is no longer required
async function waitOnNamespace(connection, namespace, maxAttempts = 100, retryIntervalSecs = 1) {
    const runId = '12345678-dead-beef-1234-1234567890ab';
    for (let attempt = 1; attempt <= maxAttempts; ++attempt) {
        try {
            await connection.workflowService.getWorkflowExecutionHistory({
                namespace,
                execution: { workflowId: 'fake', runId },
            });
        }
        catch (err) {
            if (err.details.includes('workflow history not found') ||
                err.details.includes('Workflow executionsRow not found') ||
                err.details.includes('operation GetCurrentExecution') ||
                err.details.includes('operation GetWorkflowExecution encountered not found') ||
                err.details.includes(runId)) {
                break;
            }
            if (attempt === maxAttempts) {
                throw err;
            }
            await new Promise((resolve) => setTimeout(resolve, retryIntervalSecs * 1000));
        }
    }
}
exports.waitOnNamespace = waitOnNamespace;
async function createNamespace(connection, namespace, maxAttempts = 100, retryIntervalSecs = 1) {
    for (let attempt = 1; attempt <= maxAttempts; ++attempt) {
        try {
            await connection.workflowService.registerNamespace({
                namespace,
                workflowExecutionRetentionPeriod: (0, time_1.msToTs)('1 day'),
            });
            break;
        }
        catch (err) {
            if (err.details === 'Namespace already exists.') {
                break;
            }
            if (attempt === maxAttempts) {
                throw err;
            }
            await new Promise((resolve) => setTimeout(resolve, retryIntervalSecs * 1000));
        }
    }
}
exports.createNamespace = createNamespace;
//# sourceMappingURL=utils.js.map