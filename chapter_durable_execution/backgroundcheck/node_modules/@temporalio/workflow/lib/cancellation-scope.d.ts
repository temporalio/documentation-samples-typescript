/// <reference types="node" />
import type { AsyncLocalStorage as ALS } from 'node:async_hooks';
import { Duration } from '@temporalio/common';
export declare const AsyncLocalStorage: new <T>() => ALS<T>;
/** Magic symbol used to create the root scope - intentionally not exported */
declare const NO_PARENT: unique symbol;
/**
 * Option for constructing a CancellationScope
 */
export interface CancellationScopeOptions {
    /**
     * Time in milliseconds before the scope cancellation is automatically requested
     */
    timeout?: number;
    /**
     * If false, prevent outer cancellation from propagating to inner scopes, Activities, timers, and Triggers, defaults to true.
     * (Scope still propagates CancelledFailure thrown from within).
     */
    cancellable: boolean;
    /**
     * An optional CancellationScope (useful for running background tasks).
     * The `NO_PARENT` symbol is reserved for the root scope.
     */
    parent?: CancellationScope | typeof NO_PARENT;
}
/**
 * In the SDK, Workflows are represented internally by a tree of scopes where the `execute` function runs in the root scope.
 * Cancellation propagates from outer scopes to inner ones and is handled by catching {@link CancelledFailure}s
 * thrown by cancellable operations (see below).
 *
 * Scopes are created using the `CancellationScope` constructor or the static helper methods
 * {@link cancellable}, {@link nonCancellable} and {@link withTimeout}.
 *
 * When a `CancellationScope` is cancelled, it will propagate cancellation any child scopes and any cancellable
 * operations created within it, such as:
 *
 * - Activities
 * - Child Workflows
 * - Timers (created with the {@link sleep} function)
 * - {@link Trigger}s
 *
 * @example
 *
 * ```ts
 * await CancellationScope.cancellable(async () => {
 *   const promise = someActivity();
 *   CancellationScope.current().cancel(); // Cancels the activity
 *   await promise; // Throws `ActivityFailure` with `cause` set to `CancelledFailure`
 * });
 * ```
 *
 * @example
 *
 * ```ts
 * const scope = new CancellationScope();
 * const promise = scope.run(someActivity);
 * scope.cancel(); // Cancels the activity
 * await promise; // Throws `ActivityFailure` with `cause` set to `CancelledFailure`
 * ```
 */
export declare class CancellationScope {
    #private;
    /**
     * Time in milliseconds before the scope cancellation is automatically requested
     */
    protected readonly timeout?: number;
    /**
     * If false, prevent outer cancellation from propagating to inner scopes, Activities, timers, and Triggers, defaults to true.
     * (Scope still propagates CancelledFailure thrown from within)
     */
    readonly cancellable: boolean;
    /**
     * An optional CancellationScope (useful for running background tasks), defaults to {@link CancellationScope.current}()
     */
    readonly parent?: CancellationScope;
    /**
     * Rejected when scope cancellation is requested
     */
    readonly cancelRequested: Promise<never>;
    protected readonly reject: (reason?: any) => void;
    constructor(options?: CancellationScopeOptions);
    get consideredCancelled(): boolean;
    /**
     * Activate the scope as current and run  `fn`
     *
     * Any timers, Activities, Triggers and CancellationScopes created in the body of `fn`
     * automatically link their cancellation to this scope.
     *
     * @return the result of `fn`
     */
    run<T>(fn: () => Promise<T>): Promise<T>;
    /**
     * Method that runs a function in AsyncLocalStorage context.
     *
     * Could have been written as anonymous function, made into a method for improved stack traces.
     */
    protected runInContext<T>(fn: () => Promise<T>): Promise<T>;
    /**
     * Request to cancel the scope and linked children
     */
    cancel(): void;
    /**
     * Get the current "active" scope
     */
    static current(): CancellationScope;
    /** Alias to `new CancellationScope({ cancellable: true }).run(fn)` */
    static cancellable<T>(fn: () => Promise<T>): Promise<T>;
    /** Alias to `new CancellationScope({ cancellable: false }).run(fn)` */
    static nonCancellable<T>(fn: () => Promise<T>): Promise<T>;
    /** Alias to `new CancellationScope({ cancellable: true, timeout }).run(fn)` */
    static withTimeout<T>(timeout: number, fn: () => Promise<T>): Promise<T>;
}
/**
 * Avoid exposing the storage directly so it doesn't get frozen
 */
export declare function disableStorage(): void;
export declare class RootCancellationScope extends CancellationScope {
    constructor();
    cancel(): void;
}
/** This function is here to avoid a circular dependency between this module and workflow.ts */
declare let sleep: (_: Duration) => Promise<void>;
export declare function registerSleepImplementation(fn: typeof sleep): void;
export {};
