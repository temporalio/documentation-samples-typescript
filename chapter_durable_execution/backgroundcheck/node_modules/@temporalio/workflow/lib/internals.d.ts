import type { RawSourceMap } from 'source-map';
import { FailureConverter, PayloadConverter, Workflow, WorkflowQueryType, WorkflowSignalType, ProtoFailure } from '@temporalio/common';
import type { coresdk } from '@temporalio/proto';
import { RNG } from './alea';
import { RootCancellationScope } from './cancellation-scope';
import { QueryInput, SignalInput, WorkflowExecuteInput, WorkflowInterceptors } from './interceptors';
import { DefaultSignalHandler, FileLocation, WorkflowInfo, WorkflowCreateOptionsInternal } from './interfaces';
import { SinkCall } from './sinks';
export interface Stack {
    formatted: string;
    structured: FileLocation[];
}
/**
 * Global store to track promise stacks for stack trace query
 */
export interface PromiseStackStore {
    childToParent: Map<Promise<unknown>, Set<Promise<unknown>>>;
    promiseToStack: Map<Promise<unknown>, Stack>;
}
export interface Completion {
    resolve(val: unknown): unknown;
    reject(reason: unknown): unknown;
}
export interface Condition {
    fn(): boolean;
    resolve(): void;
}
/**
 * A class that acts as a marker for this special result type
 */
export declare class LocalActivityDoBackoff extends Error {
    readonly backoff: coresdk.activity_result.IDoBackoff;
    constructor(backoff: coresdk.activity_result.IDoBackoff);
}
export type ActivationHandlerFunction<K extends keyof coresdk.workflow_activation.IWorkflowActivationJob> = (activation: NonNullable<coresdk.workflow_activation.IWorkflowActivationJob[K]>) => void;
/**
 * Verifies all activation job handling methods are implemented
 */
export type ActivationHandler = {
    [P in keyof coresdk.workflow_activation.IWorkflowActivationJob]: ActivationHandlerFunction<P>;
};
/**
 * Keeps all of the Workflow runtime state like pending completions for activities and timers.
 *
 * Implements handlers for all workflow activation jobs.
 */
export declare class Activator implements ActivationHandler {
    /**
     * Cache for modules - referenced in reusable-vm.ts
     */
    readonly moduleCache: Map<string, unknown>;
    /**
     * Map of task sequence to a Completion
     */
    readonly completions: {
        timer: Map<number, Completion>;
        activity: Map<number, Completion>;
        childWorkflowStart: Map<number, Completion>;
        childWorkflowComplete: Map<number, Completion>;
        signalWorkflow: Map<number, Completion>;
        cancelWorkflow: Map<number, Completion>;
    };
    /**
     * Holds buffered signal calls until a handler is registered
     */
    readonly bufferedSignals: coresdk.workflow_activation.ISignalWorkflow[];
    /**
     * Holds buffered query calls until a handler is registered.
     *
     * **IMPORTANT** queries are only buffered until workflow is started.
     * This is required because async interceptors might block workflow function invocation
     * which delays query handler registration.
     */
    protected readonly bufferedQueries: coresdk.workflow_activation.IQueryWorkflow[];
    /**
     * Mapping of signal name to handler
     */
    readonly signalHandlers: Map<string, WorkflowSignalType>;
    /**
     * A signal handler that catches calls for non-registered signal names.
     */
    defaultSignalHandler?: DefaultSignalHandler;
    /**
     * Source map file for looking up the source files in response to __enhanced_stack_trace
     */
    protected readonly sourceMap: RawSourceMap;
    /**
     * Whether or not to send the sources in enhanced stack trace query responses
     */
    protected readonly showStackTraceSources: boolean;
    readonly promiseStackStore: PromiseStackStore;
    readonly rootScope: RootCancellationScope;
    /**
     * Mapping of query name to handler
     */
    readonly queryHandlers: Map<string, WorkflowQueryType>;
    /**
     * Loaded in {@link initRuntime}
     */
    readonly interceptors: Required<WorkflowInterceptors>;
    /**
     * Buffer that stores all generated commands, reset after each activation
     */
    protected commands: coresdk.workflow_commands.IWorkflowCommand[];
    /**
     * Stores all {@link condition}s that haven't been unblocked yet
     */
    readonly blockedConditions: Map<number, Condition>;
    /**
     * Is this Workflow completed?
     *
     * A Workflow will be considered completed if it generates a command that the
     * system considers as a final Workflow command (e.g.
     * completeWorkflowExecution or failWorkflowExecution).
     */
    completed: boolean;
    /**
     * Was this Workflow cancelled?
     */
    protected cancelled: boolean;
    /**
     * This is tracked to allow buffering queries until a workflow function is called.
     * TODO(bergundy): I don't think this makes sense since queries run last in an activation and must be responded to in
     * the same activation.
     */
    protected workflowFunctionWasCalled: boolean;
    /**
     * The next (incremental) sequence to assign when generating completable commands
     */
    nextSeqs: {
        timer: number;
        activity: number;
        childWorkflow: number;
        signalWorkflow: number;
        cancelWorkflow: number;
        condition: number;
        stack: number;
    };
    /**
     * This is set every time the workflow executes an activation
     */
    now: number;
    /**
     * Reference to the current Workflow, initialized when a Workflow is started
     */
    workflow?: Workflow;
    /**
     * Information about the current Workflow
     */
    readonly info: WorkflowInfo;
    /**
     * A deterministic RNG, used by the isolate's overridden Math.random
     */
    random: RNG;
    payloadConverter: PayloadConverter;
    failureConverter: FailureConverter;
    /**
     * Patches we know the status of for this workflow, as in {@link patched}
     */
    readonly knownPresentPatches: Set<string>;
    /**
     * Patches we sent to core {@link patched}
     */
    readonly sentPatches: Set<string>;
    /**
     * Buffered sink calls per activation
     */
    sinkCalls: SinkCall[];
    /**
     * A nanosecond resolution time function, externally injected
     */
    readonly getTimeOfDay: () => bigint;
    readonly registeredActivityNames: Set<string>;
    constructor({ info, now, showStackTraceSources, sourceMap, getTimeOfDay, randomnessSeed, patches, registeredActivityNames, }: WorkflowCreateOptionsInternal);
    protected getStackTraces(): Stack[];
    getAndResetSinkCalls(): SinkCall[];
    /**
     * Buffer a Workflow command to be collected at the end of the current activation.
     *
     * Prevents commands from being added after Workflow completion.
     */
    pushCommand(cmd: coresdk.workflow_commands.IWorkflowCommand, complete?: boolean): void;
    getAndResetCommands(): coresdk.workflow_commands.IWorkflowCommand[];
    startWorkflowNextHandler({ args }: WorkflowExecuteInput): Promise<any>;
    startWorkflow(activation: coresdk.workflow_activation.IStartWorkflow): void;
    cancelWorkflow(_activation: coresdk.workflow_activation.ICancelWorkflow): void;
    fireTimer(activation: coresdk.workflow_activation.IFireTimer): void;
    resolveActivity(activation: coresdk.workflow_activation.IResolveActivity): void;
    resolveChildWorkflowExecutionStart(activation: coresdk.workflow_activation.IResolveChildWorkflowExecutionStart): void;
    resolveChildWorkflowExecution(activation: coresdk.workflow_activation.IResolveChildWorkflowExecution): void;
    protected queryWorkflowNextHandler({ queryName, args }: QueryInput): Promise<unknown>;
    queryWorkflow(activation: coresdk.workflow_activation.IQueryWorkflow): void;
    signalWorkflowNextHandler({ signalName, args }: SignalInput): Promise<void>;
    signalWorkflow(activation: coresdk.workflow_activation.ISignalWorkflow): void;
    dispatchBufferedSignals(): void;
    resolveSignalExternalWorkflow(activation: coresdk.workflow_activation.IResolveSignalExternalWorkflow): void;
    resolveRequestCancelExternalWorkflow(activation: coresdk.workflow_activation.IResolveRequestCancelExternalWorkflow): void;
    updateRandomSeed(activation: coresdk.workflow_activation.IUpdateRandomSeed): void;
    notifyHasPatch(activation: coresdk.workflow_activation.INotifyHasPatch): void;
    removeFromCache(): void;
    /**
     * Transforms failures into a command to be sent to the server.
     * Used to handle any failure emitted by the Workflow.
     */
    handleWorkflowFailure(error: unknown): Promise<void>;
    private completeQuery;
    private failQuery;
    /** Consume a completion if it exists in Workflow state */
    private maybeConsumeCompletion;
    /** Consume a completion if it exists in Workflow state, throws if it doesn't */
    private consumeCompletion;
    private completeWorkflow;
    errorToFailure(err: unknown): ProtoFailure;
    failureToError(failure: ProtoFailure): Error;
}
export declare function maybeGetActivator(): Activator | undefined;
export declare function getActivator(): Activator;
