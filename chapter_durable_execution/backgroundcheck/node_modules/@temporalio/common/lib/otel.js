"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.linkSpans = exports.headersWithContext = exports.extractSpanContextFromHeaders = exports.extractContextFromHeaders = exports.NUM_JOBS_ATTR_KEY = exports.TASK_TOKEN_ATTR_KEY = exports.RUN_ID_ATTR_KEY = exports.TRACE_HEADER = void 0;
const otel = __importStar(require("@opentelemetry/api"));
const payload_converter_1 = require("./converter/payload-converter");
/** Default trace header for opentelemetry interceptors */
exports.TRACE_HEADER = '_tracer-data';
/** As in workflow run id */
exports.RUN_ID_ATTR_KEY = 'run_id';
/** For a workflow or activity task */
exports.TASK_TOKEN_ATTR_KEY = 'task_token';
/** Number of jobs in a workflow activation */
exports.NUM_JOBS_ATTR_KEY = 'num_jobs';
const payloadConverter = payload_converter_1.defaultPayloadConverter;
/**
 * If found, return an otel Context deserialized from the provided headers
 */
async function extractContextFromHeaders(headers) {
    const encodedSpanContext = headers[exports.TRACE_HEADER];
    if (encodedSpanContext === undefined) {
        return undefined;
    }
    const textMap = payloadConverter.fromPayload(encodedSpanContext);
    return otel.propagation.extract(otel.context.active(), textMap, otel.defaultTextMapGetter);
}
exports.extractContextFromHeaders = extractContextFromHeaders;
/**
 * If found, return an otel SpanContext deserialized from the provided headers
 */
async function extractSpanContextFromHeaders(headers) {
    const context = await extractContextFromHeaders(headers);
    if (context === undefined) {
        return undefined;
    }
    return otel.trace.getSpanContext(context);
}
exports.extractSpanContextFromHeaders = extractSpanContextFromHeaders;
/**
 * Given headers, return new headers with the current otel context inserted
 */
async function headersWithContext(headers) {
    const carrier = {};
    otel.propagation.inject(otel.context.active(), carrier, otel.defaultTextMapSetter);
    return { ...headers, [exports.TRACE_HEADER]: payloadConverter.toPayload(carrier) };
}
exports.headersWithContext = headersWithContext;
/**
 * Link a span to an maybe-existing span context
 */
function linkSpans(fromSpan, toContext) {
    if (toContext !== undefined) {
        // TODO: I have to go around typescript because otel api ðŸ˜¢
        //  See https://github.com/open-telemetry/opentelemetry-js-api/issues/124
        const links = fromSpan.links;
        if (links === undefined) {
            fromSpan.links = [{ context: toContext }];
        }
        else {
            links.push({ context: toContext });
        }
    }
}
exports.linkSpans = linkSpans;
//# sourceMappingURL=otel.js.map