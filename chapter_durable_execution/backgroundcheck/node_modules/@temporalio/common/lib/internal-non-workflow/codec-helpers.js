"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.noopDecodeMap = exports.noopEncodeMap = exports.decodeOptionalFailure = exports.encodeOptionalFailure = exports.decodeFailure = exports.encodeFailure = exports.encodeErrorToFailure = exports.encodeMapToPayloads = exports.encodeMap = exports.decodeMapFromPayloads = exports.encodeToPayloads = exports.decodeOptionalMap = exports.decodeOptionalFailureToOptionalError = exports.decodeFromPayloadsAtIndex = exports.decodeArrayFromPayloads = exports.encodeToPayload = exports.decodeOptionalSingle = exports.encodeOptionalSingle = exports.decodeOptional = exports.encodeOptional = exports.encode = exports.decode = void 0;
const payload_converter_1 = require("../converter/payload-converter");
const errors_1 = require("../errors");
/**
 * Decode through each codec, starting with the last codec.
 */
async function decode(codecs, payloads) {
    for (let i = codecs.length - 1; i >= 0; i--) {
        payloads = await codecs[i].decode(payloads);
    }
    return payloads;
}
exports.decode = decode;
/**
 * Encode through each codec, starting with the first codec.
 */
async function encode(codecs, payloads) {
    for (let i = 0; i < codecs.length; i++) {
        payloads = await codecs[i].encode(payloads);
    }
    return payloads;
}
exports.encode = encode;
/** Run {@link PayloadCodec.encode} on `payloads` */
async function encodeOptional(codecs, payloads) {
    if (payloads == null)
        return payloads;
    return await encode(codecs, payloads);
}
exports.encodeOptional = encodeOptional;
/** Run {@link PayloadCodec.decode} on `payloads` */
async function decodeOptional(codecs, payloads) {
    if (payloads == null)
        return payloads;
    return await decode(codecs, payloads);
}
exports.decodeOptional = decodeOptional;
async function encodeSingle(codecs, payload) {
    const encodedPayloads = await encode(codecs, [payload]);
    return encodedPayloads[0];
}
async function decodeSingle(codecs, payload) {
    const [decodedPayload] = await decode(codecs, [payload]);
    return decodedPayload;
}
/** Run {@link PayloadCodec.encode} on a single Payload */
async function encodeOptionalSingle(codecs, payload) {
    if (payload == null)
        return payload;
    return await encodeSingle(codecs, payload);
}
exports.encodeOptionalSingle = encodeOptionalSingle;
/** Run {@link PayloadCodec.decode} on a single Payload */
async function decodeOptionalSingle(codecs, payload) {
    if (payload == null)
        return payload;
    return await decodeSingle(codecs, payload);
}
exports.decodeOptionalSingle = decodeOptionalSingle;
/**
 * Run {@link PayloadConverter.toPayload} on value, and then encode it.
 */
async function encodeToPayload(converter, value) {
    const { payloadConverter, payloadCodecs } = converter;
    return await encodeSingle(payloadCodecs, payloadConverter.toPayload(value));
}
exports.encodeToPayload = encodeToPayload;
/**
 * Decode `payloads` and then return {@link arrayFromPayloads}`.
 */
async function decodeArrayFromPayloads(converter, payloads) {
    const { payloadConverter, payloadCodecs } = converter;
    return (0, payload_converter_1.arrayFromPayloads)(payloadConverter, await decodeOptional(payloadCodecs, payloads));
}
exports.decodeArrayFromPayloads = decodeArrayFromPayloads;
/**
 * Decode `payloads` and then return {@link fromPayloadsAtIndex}.
 */
async function decodeFromPayloadsAtIndex(converter, index, payloads) {
    const { payloadConverter, payloadCodecs } = converter;
    return await (0, payload_converter_1.fromPayloadsAtIndex)(payloadConverter, index, await decodeOptional(payloadCodecs, payloads));
}
exports.decodeFromPayloadsAtIndex = decodeFromPayloadsAtIndex;
/**
 * Run {@link decodeFailure} and then return {@link failureToError}.
 */
async function decodeOptionalFailureToOptionalError(converter, failure) {
    const { failureConverter, payloadConverter, payloadCodecs } = converter;
    return failure
        ? failureConverter.failureToError(await decodeFailure(payloadCodecs, failure), payloadConverter)
        : undefined;
}
exports.decodeOptionalFailureToOptionalError = decodeOptionalFailureToOptionalError;
async function decodeOptionalMap(codecs, payloads) {
    if (payloads == null)
        return payloads;
    return Object.fromEntries(await Promise.all(Object.entries(payloads).map(async ([k, v]) => [k, await decode(codecs, [v])])));
}
exports.decodeOptionalMap = decodeOptionalMap;
/**
 * Run {@link PayloadConverter.toPayload} on values, and then encode them.
 */
async function encodeToPayloads(converter, ...values) {
    const { payloadConverter, payloadCodecs } = converter;
    if (values.length === 0) {
        return undefined;
    }
    const payloads = (0, payload_converter_1.toPayloads)(payloadConverter, ...values);
    return payloads ? await encode(payloadCodecs, payloads) : undefined;
}
exports.encodeToPayloads = encodeToPayloads;
/**
 * Run {@link PayloadCodec.decode} and then {@link PayloadConverter.fromPayload} on values in `map`.
 */
async function decodeMapFromPayloads(converter, map) {
    if (!map)
        return undefined;
    const { payloadConverter, payloadCodecs } = converter;
    return Object.fromEntries(await Promise.all(Object.entries(map).map(async ([k, payload]) => {
        const [decodedPayload] = await decode(payloadCodecs, [payload]);
        const value = payloadConverter.fromPayload(decodedPayload);
        return [k, value];
    })));
}
exports.decodeMapFromPayloads = decodeMapFromPayloads;
/** Run {@link PayloadCodec.encode} on all values in `map` */
async function encodeMap(codecs, map) {
    if (map === null)
        return null;
    if (map === undefined)
        return undefined;
    return Object.fromEntries(await Promise.all(Object.entries(map).map(async ([k, payload]) => {
        return [k, await encodeSingle(codecs, payload)];
    })));
}
exports.encodeMap = encodeMap;
/**
 * Run {@link PayloadConverter.toPayload} and then {@link PayloadCodec.encode} on values in `map`.
 */
async function encodeMapToPayloads(converter, map) {
    const { payloadConverter, payloadCodecs } = converter;
    return Object.fromEntries(await Promise.all(Object.entries(map).map(async ([k, v]) => {
        const payload = payloadConverter.toPayload(v);
        if (payload === undefined)
            throw new errors_1.PayloadConverterError(`Failed to encode entry: ${k}: ${v}`);
        const [encodedPayload] = await encode(payloadCodecs, [payload]);
        return [k, encodedPayload];
    })));
}
exports.encodeMapToPayloads = encodeMapToPayloads;
/**
 * Run {@link errorToFailure} on `error`, and then {@link encodeFailure}.
 */
async function encodeErrorToFailure(dataConverter, error) {
    const { failureConverter, payloadConverter, payloadCodecs } = dataConverter;
    return await encodeFailure(payloadCodecs, failureConverter.errorToFailure(error, payloadConverter));
}
exports.encodeErrorToFailure = encodeErrorToFailure;
/**
 * Return a new {@link ProtoFailure} with `codec.encode()` run on all the {@link Payload}s.
 */
async function encodeFailure(codecs, failure) {
    return {
        ...failure,
        encodedAttributes: failure.encodedAttributes ? (await encode(codecs, [failure.encodedAttributes]))[0] : undefined,
        cause: failure.cause ? await encodeFailure(codecs, failure.cause) : null,
        applicationFailureInfo: failure.applicationFailureInfo
            ? {
                ...failure.applicationFailureInfo,
                details: failure.applicationFailureInfo.details
                    ? {
                        payloads: await encode(codecs, failure.applicationFailureInfo.details.payloads ?? []),
                    }
                    : undefined,
            }
            : undefined,
        timeoutFailureInfo: failure.timeoutFailureInfo
            ? {
                ...failure.timeoutFailureInfo,
                lastHeartbeatDetails: failure.timeoutFailureInfo.lastHeartbeatDetails
                    ? {
                        payloads: await encode(codecs, failure.timeoutFailureInfo.lastHeartbeatDetails.payloads ?? []),
                    }
                    : undefined,
            }
            : undefined,
        canceledFailureInfo: failure.canceledFailureInfo
            ? {
                ...failure.canceledFailureInfo,
                details: failure.canceledFailureInfo.details
                    ? {
                        payloads: await encode(codecs, failure.canceledFailureInfo.details.payloads ?? []),
                    }
                    : undefined,
            }
            : undefined,
        resetWorkflowFailureInfo: failure.resetWorkflowFailureInfo
            ? {
                ...failure.resetWorkflowFailureInfo,
                lastHeartbeatDetails: failure.resetWorkflowFailureInfo.lastHeartbeatDetails
                    ? {
                        payloads: await encode(codecs, failure.resetWorkflowFailureInfo.lastHeartbeatDetails.payloads ?? []),
                    }
                    : undefined,
            }
            : undefined,
    };
}
exports.encodeFailure = encodeFailure;
/**
 * Return a new {@link ProtoFailure} with `codec.decode()` run on all the {@link Payload}s.
 */
async function decodeFailure(codecs, failure) {
    return {
        ...failure,
        encodedAttributes: failure.encodedAttributes ? (await decode(codecs, [failure.encodedAttributes]))[0] : undefined,
        cause: failure.cause ? await decodeFailure(codecs, failure.cause) : null,
        applicationFailureInfo: failure.applicationFailureInfo
            ? {
                ...failure.applicationFailureInfo,
                details: failure.applicationFailureInfo.details
                    ? {
                        payloads: await decode(codecs, failure.applicationFailureInfo.details.payloads ?? []),
                    }
                    : undefined,
            }
            : undefined,
        timeoutFailureInfo: failure.timeoutFailureInfo
            ? {
                ...failure.timeoutFailureInfo,
                lastHeartbeatDetails: failure.timeoutFailureInfo.lastHeartbeatDetails
                    ? {
                        payloads: await decode(codecs, failure.timeoutFailureInfo.lastHeartbeatDetails.payloads ?? []),
                    }
                    : undefined,
            }
            : undefined,
        canceledFailureInfo: failure.canceledFailureInfo
            ? {
                ...failure.canceledFailureInfo,
                details: failure.canceledFailureInfo.details
                    ? {
                        payloads: await decode(codecs, failure.canceledFailureInfo.details.payloads ?? []),
                    }
                    : undefined,
            }
            : undefined,
        resetWorkflowFailureInfo: failure.resetWorkflowFailureInfo
            ? {
                ...failure.resetWorkflowFailureInfo,
                lastHeartbeatDetails: failure.resetWorkflowFailureInfo.lastHeartbeatDetails
                    ? {
                        payloads: await decode(codecs, failure.resetWorkflowFailureInfo.lastHeartbeatDetails.payloads ?? []),
                    }
                    : undefined,
            }
            : undefined,
    };
}
exports.decodeFailure = decodeFailure;
/**
 * Return a new {@link ProtoFailure} with `codec.encode()` run on all the {@link Payload}s.
 */
async function encodeOptionalFailure(codecs, failure) {
    if (failure == null)
        return failure;
    return await encodeFailure(codecs, failure);
}
exports.encodeOptionalFailure = encodeOptionalFailure;
/**
 * Return a new {@link ProtoFailure} with `codec.encode()` run on all the {@link Payload}s.
 */
async function decodeOptionalFailure(codecs, failure) {
    if (failure == null)
        return failure;
    return await decodeFailure(codecs, failure);
}
exports.decodeOptionalFailure = decodeOptionalFailure;
/**
 * Mark all values in the map as encoded.
 * Use this for headers, which we don't encode.
 */
function noopEncodeMap(map) {
    return map;
}
exports.noopEncodeMap = noopEncodeMap;
/**
 * Mark all values in the map as decoded.
 * Use this for headers, which we don't encode.
 */
function noopDecodeMap(map) {
    return map;
}
exports.noopDecodeMap = noopDecodeMap;
//# sourceMappingURL=codec-helpers.js.map