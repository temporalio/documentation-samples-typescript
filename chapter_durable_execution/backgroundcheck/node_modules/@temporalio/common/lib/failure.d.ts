import type { temporal } from '@temporalio/proto';
export declare const FAILURE_SOURCE = "TypeScriptSDK";
export type ProtoFailure = temporal.api.failure.v1.IFailure;
export declare enum TimeoutType {
    TIMEOUT_TYPE_UNSPECIFIED = 0,
    TIMEOUT_TYPE_START_TO_CLOSE = 1,
    TIMEOUT_TYPE_SCHEDULE_TO_START = 2,
    TIMEOUT_TYPE_SCHEDULE_TO_CLOSE = 3,
    TIMEOUT_TYPE_HEARTBEAT = 4
}
export declare enum RetryState {
    RETRY_STATE_UNSPECIFIED = 0,
    RETRY_STATE_IN_PROGRESS = 1,
    RETRY_STATE_NON_RETRYABLE_FAILURE = 2,
    RETRY_STATE_TIMEOUT = 3,
    RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED = 4,
    RETRY_STATE_RETRY_POLICY_NOT_SET = 5,
    RETRY_STATE_INTERNAL_SERVER_ERROR = 6,
    RETRY_STATE_CANCEL_REQUESTED = 7
}
export type WorkflowExecution = temporal.api.common.v1.IWorkflowExecution;
/**
 * Represents failures that can cross Workflow and Activity boundaries.
 *
 * **Never extend this class or any of its children.**
 *
 * The only child class you should ever throw from your code is {@link ApplicationFailure}.
 */
export declare class TemporalFailure extends Error {
    readonly cause?: Error | undefined;
    /**
     * The original failure that constructed this error.
     *
     * Only present if this error was generated from an external operation.
     */
    failure?: ProtoFailure;
    constructor(message?: string | undefined | null, cause?: Error | undefined);
}
/** Exceptions originated at the Temporal service. */
export declare class ServerFailure extends TemporalFailure {
    readonly nonRetryable: boolean;
    constructor(message: string | undefined, nonRetryable: boolean, cause?: Error);
}
/**
 * `ApplicationFailure`s are used to communicate application-specific failures in Workflows and Activities.
 *
 * The {@link type} property is matched against {@link RetryPolicy.nonRetryableErrorTypes} to determine if an instance
 * of this error is retryable. Another way to avoid retrying is by setting the {@link nonRetryable} flag to `true`.
 *
 * In Workflows, if you throw a non-`ApplicationFailure`, the Workflow Task will fail and be retried. If you throw an
 * `ApplicationFailure`, the Workflow Execution will fail.
 *
 * In Activities, you can either throw an `ApplicationFailure` or another `Error` to fail the Activity Task. In the
 * latter case, the `Error` will be converted to an `ApplicationFailure`. The conversion is done as following:
 *
 * - `type` is set to `error.constructor?.name ?? error.name`
 * - `message` is set to `error.message`
 * - `nonRetryable` is set to false
 * - `details` are set to null
 * - stack trace is copied from the original error
 *
 * When an {@link https://docs.temporal.io/concepts/what-is-an-activity-execution | Activity Execution} fails, the
 * `ApplicationFailure` from the last Activity Task will be the `cause` of the {@link ActivityFailure} thrown in the
 * Workflow.
 */
export declare class ApplicationFailure extends TemporalFailure {
    readonly type?: string | null | undefined;
    readonly nonRetryable?: boolean | null | undefined;
    readonly details?: unknown[] | null | undefined;
    /**
     * Alternatively, use {@link fromError} or {@link create}.
     */
    constructor(message?: string | undefined | null, type?: string | null | undefined, nonRetryable?: boolean | null | undefined, details?: unknown[] | null | undefined, cause?: Error);
    /**
     * Create a new `ApplicationFailure` from an Error object.
     *
     * First calls {@link ensureApplicationFailure | `ensureApplicationFailure(error)`} and then overrides any fields
     * provided in `overrides`.
     */
    static fromError(error: Error | unknown, overrides?: ApplicationFailureOptions): ApplicationFailure;
    /**
     * Create a new `ApplicationFailure`.
     *
     * By default, will be retryable (unless its `type` is included in {@link RetryPolicy.nonRetryableErrorTypes}).
     */
    static create(options: ApplicationFailureOptions): ApplicationFailure;
    /**
     * Get a new `ApplicationFailure` with the {@link nonRetryable} flag set to false. Note that this error will still
     * not be retried if its `type` is included in {@link RetryPolicy.nonRetryableErrorTypes}.
     *
     * @param message Optional error message
     * @param type Optional error type (used by {@link RetryPolicy.nonRetryableErrorTypes})
     * @param details Optional details about the failure. Serialized by the Worker's {@link PayloadConverter}.
     */
    static retryable(message?: string | null, type?: string | null, ...details: unknown[]): ApplicationFailure;
    /**
     * Get a new `ApplicationFailure` with the {@link nonRetryable} flag set to true.
     *
     * When thrown from an Activity or Workflow, the Activity or Workflow will not be retried (even if `type` is not
     * listed in {@link RetryPolicy.nonRetryableErrorTypes}).
     *
     * @param message Optional error message
     * @param type Optional error type
     * @param details Optional details about the failure. Serialized by the Worker's {@link PayloadConverter}.
     */
    static nonRetryable(message?: string | null, type?: string | null, ...details: unknown[]): ApplicationFailure;
}
export interface ApplicationFailureOptions {
    /**
     * Error message
     */
    message?: string;
    /**
     * Error type (used by {@link RetryPolicy.nonRetryableErrorTypes})
     */
    type?: string;
    /**
     * Whether the current Activity or Workflow can be retried
     *
     * @default false
     */
    nonRetryable?: boolean;
    /**
     * Details about the failure. Serialized by the Worker's {@link PayloadConverter}.
     */
    details?: unknown[];
    /**
     * Cause of the failure
     */
    cause?: Error;
}
/**
 * This error is thrown when Cancellation has been requested. To allow Cancellation to happen, let it propagate. To
 * ignore Cancellation, catch it and continue executing. Note that Cancellation can only be requested a single time, so
 * your Workflow/Activity Execution will not receive further Cancellation requests.
 *
 * When a Workflow or Activity has been successfully cancelled, a `CancelledFailure` will be the `cause`.
 */
export declare class CancelledFailure extends TemporalFailure {
    readonly details: unknown[];
    constructor(message: string | undefined, details?: unknown[], cause?: Error);
}
/**
 * Used as the `cause` when a Workflow has been terminated
 */
export declare class TerminatedFailure extends TemporalFailure {
    constructor(message: string | undefined, cause?: Error);
}
/**
 * Used to represent timeouts of Activities and Workflows
 */
export declare class TimeoutFailure extends TemporalFailure {
    readonly lastHeartbeatDetails: unknown;
    readonly timeoutType: TimeoutType;
    constructor(message: string | undefined, lastHeartbeatDetails: unknown, timeoutType: TimeoutType);
}
/**
 * Contains information about an Activity failure. Always contains the original reason for the failure as its `cause`.
 * For example, if an Activity timed out, the cause will be a {@link TimeoutFailure}.
 *
 * This exception is expected to be thrown only by the framework code.
 */
export declare class ActivityFailure extends TemporalFailure {
    readonly activityType: string;
    readonly activityId: string | undefined;
    readonly retryState: RetryState;
    readonly identity: string | undefined;
    constructor(message: string | undefined, activityType: string, activityId: string | undefined, retryState: RetryState, identity: string | undefined, cause?: Error);
}
/**
 * Contains information about a Child Workflow failure. Always contains the reason for the failure as its {@link cause}.
 * For example, if the Child was Terminated, the `cause` is a {@link TerminatedFailure}.
 *
 * This exception is expected to be thrown only by the framework code.
 */
export declare class ChildWorkflowFailure extends TemporalFailure {
    readonly namespace: string | undefined;
    readonly execution: WorkflowExecution;
    readonly workflowType: string;
    readonly retryState: RetryState;
    constructor(namespace: string | undefined, execution: WorkflowExecution, workflowType: string, retryState: RetryState, cause?: Error);
}
/**
 * If `error` is already an `ApplicationFailure`, returns `error`.
 *
 * Otherwise, converts `error` into an `ApplicationFailure` with:
 *
 * - `message`: `error.message` or `String(error)`
 * - `type`: `error.constructor.name` or `error.name`
 * - `stack`: `error.stack` or `''`
 */
export declare function ensureApplicationFailure(error: unknown): ApplicationFailure;
/**
 * If `err` is an Error it is turned into an `ApplicationFailure`.
 *
 * If `err` was already a `TemporalFailure`, returns the original error.
 *
 * Otherwise returns an `ApplicationFailure` with `String(err)` as the message.
 */
export declare function ensureTemporalFailure(err: unknown): TemporalFailure;
/**
 * Get the root cause message of given `error`.
 *
 * In case `error` is a {@link TemporalFailure}, recurse the `cause` chain and return the root `cause.message`.
 * Otherwise, return `error.message`.
 */
export declare function rootCause(error: unknown): string | undefined;
