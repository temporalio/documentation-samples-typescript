"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeScheduleRecentActions = exports.decodeScheduleRunningActions = exports.decodeSearchAttributes = exports.decodeScheduleAction = exports.decodeScheduleSpec = exports.encodeScheduleState = exports.encodeSchedulePolicies = exports.encodeScheduleAction = exports.encodeScheduleSpec = exports.compileUpdatedScheduleOptions = exports.compileScheduleOptions = exports.decodeOverlapPolicy = exports.encodeOverlapPolicy = exports.decodeOptionalStructuredCalendarSpecs = exports.encodeOptionalStructuredCalendarSpecs = void 0;
const long_1 = __importDefault(require("long")); // eslint-disable-line import/no-named-as-default
const common_1 = require("@temporalio/common");
const internal_non_workflow_1 = require("@temporalio/common/lib/internal-non-workflow");
const proto_1 = require("@temporalio/proto");
const time_1 = require("@temporalio/common/lib/time");
const schedule_types_1 = require("./schedule-types");
const [encodeSecond, decodeSecond] = makeCalendarSpecFieldCoders('second', (x) => (typeof x === 'number' && x >= 0 && x <= 59 ? x : undefined), (x) => x, [{ start: 0, end: 0, step: 0 }], // default to 0
[{ start: 0, end: 59, step: 1 }]);
const [encodeMinute, decodeMinue] = makeCalendarSpecFieldCoders('minute', (x) => (typeof x === 'number' && x >= 0 && x <= 59 ? x : undefined), (x) => x, [{ start: 0, end: 0, step: 0 }], // default to 0
[{ start: 0, end: 59, step: 1 }]);
const [encodeHour, decodeHour] = makeCalendarSpecFieldCoders('hour', (x) => (typeof x === 'number' && x >= 0 && x <= 23 ? x : undefined), (x) => x, [{ start: 0, end: 0, step: 0 }], // default to 0
[{ start: 0, end: 23, step: 1 }]);
const [encodeDayOfMonth, decodeDayOfMonth] = makeCalendarSpecFieldCoders('dayOfMonth', (x) => (typeof x === 'number' && x >= 0 && x <= 31 ? x : undefined), (x) => x, [{ start: 1, end: 31, step: 1 }], // default to *
[{ start: 1, end: 31, step: 1 }]);
const [encodeMonth, decodeMonth] = makeCalendarSpecFieldCoders('month', function monthNameToNumber(month) {
    const index = schedule_types_1.MONTHS.indexOf(month);
    return index >= 0 ? index + 1 : undefined;
}, (month) => schedule_types_1.MONTHS[month - 1], [{ start: 1, end: 12, step: 1 }], // default to *
[{ start: 1, end: 12, step: 1 }]);
const [encodeYear, decodeYear] = makeCalendarSpecFieldCoders('year', (x) => (typeof x === 'number' ? x : undefined), (x) => x, [], // default to *
[] // special case: * for years is encoded as no range at all
);
const [encodeDayOfWeek, decodeDayOfWeek] = makeCalendarSpecFieldCoders('dayOfWeek', function dayOfWeekNameToNumber(day) {
    const index = schedule_types_1.DAYS_OF_WEEK.indexOf(day);
    return index >= 0 ? index : undefined;
}, (day) => schedule_types_1.DAYS_OF_WEEK[day], [{ start: 0, end: 6, step: 1 }], // default to *
[{ start: 0, end: 6, step: 1 }]);
function makeCalendarSpecFieldCoders(fieldName, encodeValueFn, decodeValueFn, defaultValue, matchAllValue) {
    function encoder(input) {
        if (input === undefined)
            return defaultValue;
        if (input === '*')
            return matchAllValue;
        return (Array.isArray(input) ? input : [input]).map((item) => {
            if (typeof item === 'object' && item.start !== undefined) {
                const range = item;
                const start = encodeValueFn(range.start);
                if (start !== undefined) {
                    return {
                        start,
                        end: range.end !== undefined ? encodeValueFn(range.end) ?? start : 1,
                        step: typeof range.step === 'number' && range.step > 0 ? range.step : 1,
                    };
                }
            }
            if (item !== undefined) {
                const value = encodeValueFn(item);
                if (value !== undefined)
                    return { start: value, end: value, step: 1 };
            }
            throw new TypeError(`Invalid CalendarSpec component for field ${fieldName}: '${item}' of type '${typeof item}'`);
        });
    }
    function decoder(input) {
        if (!input)
            return [];
        return input.map((pb) => {
            const start = decodeValueFn(pb.start);
            const end = pb.end > pb.start ? decodeValueFn(pb.end) ?? start : start;
            const step = pb.step > 0 ? pb.step : 1;
            return { start, end, step };
        });
    }
    return [encoder, decoder];
}
function encodeOptionalStructuredCalendarSpecs(input) {
    if (!input)
        return undefined;
    return input.map((spec) => ({
        second: encodeSecond(spec.second),
        minute: encodeMinute(spec.minute),
        hour: encodeHour(spec.hour),
        dayOfMonth: encodeDayOfMonth(spec.dayOfMonth),
        month: encodeMonth(spec.month),
        year: encodeYear(spec.year),
        dayOfWeek: encodeDayOfWeek(spec.dayOfWeek),
        comment: spec.comment,
    }));
}
exports.encodeOptionalStructuredCalendarSpecs = encodeOptionalStructuredCalendarSpecs;
function decodeOptionalStructuredCalendarSpecs(input) {
    if (!input)
        return [];
    return input.map((pb) => ({
        second: decodeSecond(pb.second),
        minute: decodeMinue(pb.minute),
        hour: decodeHour(pb.hour),
        dayOfMonth: decodeDayOfMonth(pb.dayOfMonth),
        month: decodeMonth(pb.month),
        year: decodeYear(pb.year),
        dayOfWeek: decodeDayOfWeek(pb.dayOfWeek),
        comment: pb.comment,
    }));
}
exports.decodeOptionalStructuredCalendarSpecs = decodeOptionalStructuredCalendarSpecs;
function encodeOverlapPolicy(input) {
    return proto_1.temporal.api.enums.v1.ScheduleOverlapPolicy[`SCHEDULE_OVERLAP_POLICY_${schedule_types_1.ScheduleOverlapPolicy[input]}`];
}
exports.encodeOverlapPolicy = encodeOverlapPolicy;
function decodeOverlapPolicy(input) {
    if (!input)
        return schedule_types_1.ScheduleOverlapPolicy.UNSPECIFIED;
    const encodedPolicyName = proto_1.temporal.api.enums.v1.ScheduleOverlapPolicy[input];
    const decodedPolicyName = encodedPolicyName.substring('SCHEDULE_OVERLAP_POLICY_'.length);
    return schedule_types_1.ScheduleOverlapPolicy[decodedPolicyName];
}
exports.decodeOverlapPolicy = decodeOverlapPolicy;
function compileScheduleOptions(options) {
    const workflowTypeOrFunc = options.action.workflowType;
    const workflowType = (0, common_1.extractWorkflowType)(workflowTypeOrFunc);
    return {
        ...options,
        action: {
            ...options.action,
            workflowId: options.action.workflowId ?? `${options.scheduleId}-workflow`,
            workflowType,
            args: (options.action.args ?? []),
        },
    };
}
exports.compileScheduleOptions = compileScheduleOptions;
function compileUpdatedScheduleOptions(scheduleId, options) {
    const workflowTypeOrFunc = options.action.workflowType;
    const workflowType = (0, common_1.extractWorkflowType)(workflowTypeOrFunc);
    return {
        ...options,
        action: {
            ...options.action,
            workflowId: options.action.workflowId ?? `${scheduleId}-workflow`,
            workflowType,
            args: (options.action.args ?? []),
        },
    };
}
exports.compileUpdatedScheduleOptions = compileUpdatedScheduleOptions;
function encodeScheduleSpec(spec) {
    return {
        structuredCalendar: encodeOptionalStructuredCalendarSpecs(spec.calendars),
        interval: spec.intervals?.map((interval) => ({
            interval: (0, time_1.msToTs)(interval.every),
            phase: (0, time_1.msOptionalToTs)(interval.offset),
        })),
        cronString: spec.cronExpressions,
        excludeStructuredCalendar: encodeOptionalStructuredCalendarSpecs(spec.skip),
        startTime: (0, time_1.optionalDateToTs)(spec.startAt),
        endTime: (0, time_1.optionalDateToTs)(spec.endAt),
        jitter: (0, time_1.msOptionalToTs)(spec.jitter),
        timezoneName: spec.timezone,
    };
}
exports.encodeScheduleSpec = encodeScheduleSpec;
async function encodeScheduleAction(dataConverter, action, headers) {
    return {
        startWorkflow: {
            workflowId: action.workflowId,
            workflowType: {
                name: action.workflowType,
            },
            input: { payloads: await (0, internal_non_workflow_1.encodeToPayloads)(dataConverter, ...action.args) },
            taskQueue: {
                kind: proto_1.temporal.api.enums.v1.TaskQueueKind.TASK_QUEUE_KIND_UNSPECIFIED,
                name: action.taskQueue,
            },
            workflowExecutionTimeout: (0, time_1.msOptionalToTs)(action.workflowExecutionTimeout),
            workflowRunTimeout: (0, time_1.msOptionalToTs)(action.workflowRunTimeout),
            workflowTaskTimeout: (0, time_1.msOptionalToTs)(action.workflowTaskTimeout),
            retryPolicy: action.retry ? (0, common_1.compileRetryPolicy)(action.retry) : undefined,
            memo: action.memo ? { fields: await (0, internal_non_workflow_1.encodeMapToPayloads)(dataConverter, action.memo) } : undefined,
            searchAttributes: action.searchAttributes
                ? {
                    indexedFields: (0, common_1.mapToPayloads)(common_1.searchAttributePayloadConverter, action.searchAttributes),
                }
                : undefined,
            header: { fields: headers },
        },
    };
}
exports.encodeScheduleAction = encodeScheduleAction;
function encodeSchedulePolicies(policies) {
    return {
        catchupWindow: (0, time_1.msOptionalToTs)(policies?.catchupWindow),
        overlapPolicy: policies?.overlap ? encodeOverlapPolicy(policies.overlap) : undefined,
        pauseOnFailure: policies?.pauseOnFailure,
    };
}
exports.encodeSchedulePolicies = encodeSchedulePolicies;
function encodeScheduleState(state) {
    return {
        paused: state?.paused,
        notes: state?.note,
        limitedActions: state?.remainingActions !== undefined,
        remainingActions: state?.remainingActions ? long_1.default.fromNumber(state?.remainingActions) : undefined,
    };
}
exports.encodeScheduleState = encodeScheduleState;
function decodeScheduleSpec(pb) {
    // Note: the server will have compiled calendar and cron_string fields into
    // structured_calendar (and maybe interval and timezone_name), so at this
    // point, we'll see only structured_calendar, interval, etc.
    return {
        calendars: decodeOptionalStructuredCalendarSpecs(pb.structuredCalendar),
        intervals: (pb.interval ?? []).map((x) => ({
            every: (0, time_1.optionalTsToMs)(x.interval),
            offset: (0, time_1.optionalTsToMs)(x.phase),
        })),
        skip: decodeOptionalStructuredCalendarSpecs(pb.excludeStructuredCalendar),
        startAt: (0, time_1.optionalTsToDate)(pb.startTime),
        endAt: (0, time_1.optionalTsToDate)(pb.endTime),
        jitter: (0, time_1.optionalTsToMs)(pb.jitter),
        timezone: pb.timezoneName ?? undefined,
    };
}
exports.decodeScheduleSpec = decodeScheduleSpec;
async function decodeScheduleAction(dataConverter, pb) {
    if (pb.startWorkflow) {
        return {
            type: 'startWorkflow',
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            workflowId: pb.startWorkflow.workflowId,
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            workflowType: pb.startWorkflow.workflowType.name,
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            taskQueue: pb.startWorkflow.taskQueue.name,
            args: await (0, internal_non_workflow_1.decodeArrayFromPayloads)(dataConverter, pb.startWorkflow.input?.payloads),
            memo: await (0, internal_non_workflow_1.decodeMapFromPayloads)(dataConverter, pb.startWorkflow.memo?.fields),
            retry: (0, common_1.decompileRetryPolicy)(pb.startWorkflow.retryPolicy),
            searchAttributes: Object.fromEntries(Object.entries((0, common_1.mapFromPayloads)(common_1.searchAttributePayloadConverter, pb.startWorkflow.searchAttributes?.indexedFields ?? {}))),
            workflowExecutionTimeout: (0, time_1.optionalTsToMs)(pb.startWorkflow.workflowExecutionTimeout),
            workflowRunTimeout: (0, time_1.optionalTsToMs)(pb.startWorkflow.workflowRunTimeout),
            workflowTaskTimeout: (0, time_1.optionalTsToMs)(pb.startWorkflow.workflowTaskTimeout),
        };
    }
    throw new TypeError('Unsupported schedule action');
}
exports.decodeScheduleAction = decodeScheduleAction;
function decodeSearchAttributes(pb) {
    if (!pb?.indexedFields)
        return {};
    return Object.fromEntries(Object.entries((0, common_1.mapFromPayloads)(common_1.searchAttributePayloadConverter, pb.indexedFields)).filter(([_, v]) => v && v.length > 0) // Filter out empty arrays returned by pre 1.18 servers
    );
}
exports.decodeSearchAttributes = decodeSearchAttributes;
function decodeScheduleRunningActions(pb) {
    if (!pb)
        return [];
    return pb.map((x) => ({
        type: 'startWorkflow',
        workflow: {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            workflowId: x.workflowId,
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            firstExecutionRunId: x.runId,
        },
    }));
}
exports.decodeScheduleRunningActions = decodeScheduleRunningActions;
function decodeScheduleRecentActions(pb) {
    if (!pb)
        return [];
    return pb.map((executionResult) => {
        let action;
        if (executionResult.startWorkflowResult) {
            action = {
                type: 'startWorkflow',
                workflow: {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    workflowId: executionResult.startWorkflowResult.workflowId,
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    firstExecutionRunId: executionResult.startWorkflowResult.runId,
                },
            };
        }
        else
            throw new TypeError('Unsupported schedule action');
        return {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            scheduledAt: (0, time_1.tsToDate)(executionResult.scheduleTime),
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            takenAt: (0, time_1.tsToDate)(executionResult.actualTime),
            action,
        };
    });
}
exports.decodeScheduleRecentActions = decodeScheduleRecentActions;
//# sourceMappingURL=schedule-helpers.js.map