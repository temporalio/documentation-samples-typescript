"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueryNotRegisteredError = exports.QueryRejectedError = exports.WorkflowClient = void 0;
const grpc_js_1 = require("@grpc/grpc-js");
const uuid_1 = require("uuid");
const common_1 = require("@temporalio/common");
const interceptors_1 = require("@temporalio/common/lib/interceptors");
const type_helpers_1 = require("@temporalio/common/lib/type-helpers");
const internal_non_workflow_1 = require("@temporalio/common/lib/internal-non-workflow");
const proto_1 = require("@temporalio/proto");
const errors_1 = require("./errors");
const workflow_options_1 = require("./workflow-options");
const helpers_1 = require("./helpers");
const base_client_1 = require("./base-client");
const iterators_utils_1 = require("./iterators-utils");
function defaultWorkflowClientOptions() {
    return {
        ...(0, base_client_1.defaultBaseClientOptions)(),
        interceptors: [],
        queryRejectCondition: proto_1.temporal.api.enums.v1.QueryRejectCondition.QUERY_REJECT_CONDITION_UNSPECIFIED,
    };
}
function assertRequiredWorkflowOptions(opts) {
    if (!opts.taskQueue) {
        throw new TypeError('Missing WorkflowOptions.taskQueue');
    }
    if (!opts.workflowId) {
        throw new TypeError('Missing WorkflowOptions.workflowId');
    }
}
function ensureArgs(opts) {
    const { args, ...rest } = opts;
    return { args: args ?? [], ...rest };
}
/**
 * Client for starting Workflow executions and creating Workflow handles.
 *
 * Typically this client should not be instantiated directly, instead create the high level {@link Client} and use
 * {@link Client.workflow} to interact with Workflows.
 */
class WorkflowClient extends base_client_1.BaseClient {
    constructor(options) {
        super(options);
        this.options = {
            ...defaultWorkflowClientOptions(),
            ...(0, internal_non_workflow_1.filterNullAndUndefined)(options ?? {}),
            loadedDataConverter: this.dataConverter,
        };
    }
    /**
     * Raw gRPC access to the Temporal service.
     *
     * **NOTE**: The namespace provided in {@link options} is **not** automatically set on requests made via this service
     * object.
     */
    get workflowService() {
        return this.connection.workflowService;
    }
    /**
     * Start a new Workflow execution.
     *
     * @returns the execution's `runId`.
     */
    async _start(workflowTypeOrFunc, options, interceptors) {
        const workflowType = (0, common_1.extractWorkflowType)(workflowTypeOrFunc);
        assertRequiredWorkflowOptions(options);
        const compiledOptions = (0, workflow_options_1.compileWorkflowOptions)(ensureArgs(options));
        const start = (0, interceptors_1.composeInterceptors)(interceptors, 'start', this._startWorkflowHandler.bind(this));
        return start({
            options: compiledOptions,
            headers: {},
            workflowType,
        });
    }
    /**
     * Sends a signal to a running Workflow or starts a new one if not already running and immediately signals it.
     * Useful when you're unsure of the Workflows' run state.
     *
     * @returns the runId of the Workflow
     */
    async _signalWithStart(workflowTypeOrFunc, options, interceptors) {
        const workflowType = (0, common_1.extractWorkflowType)(workflowTypeOrFunc);
        const { signal, signalArgs, ...rest } = options;
        assertRequiredWorkflowOptions(rest);
        const compiledOptions = (0, workflow_options_1.compileWorkflowOptions)(ensureArgs(rest));
        const signalWithStart = (0, interceptors_1.composeInterceptors)(interceptors, 'signalWithStart', this._signalWithStartWorkflowHandler.bind(this));
        return signalWithStart({
            options: compiledOptions,
            headers: {},
            workflowType,
            signalName: typeof signal === 'string' ? signal : signal.name,
            signalArgs: signalArgs ?? [],
        });
    }
    /**
     * Start a new Workflow execution.
     *
     * @returns a WorkflowHandle to the started Workflow
     */
    async start(workflowTypeOrFunc, options) {
        const { workflowId } = options;
        const interceptors = this.getOrMakeInterceptors(workflowId);
        const runId = await this._start(workflowTypeOrFunc, { ...options, workflowId }, interceptors);
        // runId is not used in handles created with `start*` calls because these
        // handles should allow interacting with the workflow if it continues as new.
        const handle = this._createWorkflowHandle({
            workflowId,
            runId: undefined,
            firstExecutionRunId: runId,
            runIdForResult: runId,
            interceptors,
            followRuns: options.followRuns ?? true,
        }); // Cast is safe because we know we add the firstExecutionRunId below
        handle /* readonly */.firstExecutionRunId = runId;
        return handle;
    }
    /**
     * Sends a Signal to a running Workflow or starts a new one if not already running and immediately Signals it.
     * Useful when you're unsure whether the Workflow has been started.
     *
     * @returns a {@link WorkflowHandle} to the started Workflow
     */
    async signalWithStart(workflowTypeOrFunc, options) {
        const { workflowId } = options;
        const interceptors = this.getOrMakeInterceptors(workflowId);
        const runId = await this._signalWithStart(workflowTypeOrFunc, options, interceptors);
        // runId is not used in handles created with `start*` calls because these
        // handles should allow interacting with the workflow if it continues as new.
        const handle = this._createWorkflowHandle({
            workflowId,
            runId: undefined,
            firstExecutionRunId: undefined,
            runIdForResult: runId,
            interceptors,
            followRuns: options.followRuns ?? true,
        }); // Cast is safe because we know we add the signaledRunId below
        handle /* readonly */.signaledRunId = runId;
        return handle;
    }
    /**
     * Starts a new Workflow execution and awaits its completion.
     *
     * @returns the result of the Workflow execution
     */
    async execute(workflowTypeOrFunc, options) {
        const { workflowId } = options;
        const interceptors = this.getOrMakeInterceptors(workflowId);
        await this._start(workflowTypeOrFunc, options, interceptors);
        return await this.result(workflowId, undefined, {
            ...options,
            followRuns: options.followRuns ?? true,
        });
    }
    /**
     * Gets the result of a Workflow execution.
     *
     * Follows the chain of execution in case Workflow continues as new, or has a cron schedule or retry policy.
     */
    async result(workflowId, runId, opts) {
        const followRuns = opts?.followRuns ?? true;
        const execution = { workflowId, runId };
        const req = {
            namespace: this.options.namespace,
            execution,
            skipArchival: true,
            waitNewEvent: true,
            historyEventFilterType: proto_1.temporal.api.enums.v1.HistoryEventFilterType.HISTORY_EVENT_FILTER_TYPE_CLOSE_EVENT,
        };
        let ev;
        for (;;) {
            let res;
            try {
                res = await this.workflowService.getWorkflowExecutionHistory(req);
            }
            catch (err) {
                this.rethrowGrpcError(err, 'Failed to get Workflow execution history', { workflowId, runId });
            }
            const events = res.history?.events;
            if (events == null || events.length === 0) {
                req.nextPageToken = res.nextPageToken;
                continue;
            }
            if (events.length !== 1) {
                throw new Error(`Expected at most 1 close event(s), got: ${events.length}`);
            }
            ev = events[0];
            if (ev.workflowExecutionCompletedEventAttributes) {
                if (followRuns && ev.workflowExecutionCompletedEventAttributes.newExecutionRunId) {
                    execution.runId = ev.workflowExecutionCompletedEventAttributes.newExecutionRunId;
                    req.nextPageToken = undefined;
                    continue;
                }
                // Note that we can only return one value from our workflow function in JS.
                // Ignore any other payloads in result
                const [result] = await (0, internal_non_workflow_1.decodeArrayFromPayloads)(this.dataConverter, ev.workflowExecutionCompletedEventAttributes.result?.payloads);
                return result;
            }
            else if (ev.workflowExecutionFailedEventAttributes) {
                if (followRuns && ev.workflowExecutionFailedEventAttributes.newExecutionRunId) {
                    execution.runId = ev.workflowExecutionFailedEventAttributes.newExecutionRunId;
                    req.nextPageToken = undefined;
                    continue;
                }
                const { failure, retryState } = ev.workflowExecutionFailedEventAttributes;
                throw new errors_1.WorkflowFailedError('Workflow execution failed', await (0, internal_non_workflow_1.decodeOptionalFailureToOptionalError)(this.dataConverter, failure), retryState ?? common_1.RetryState.RETRY_STATE_UNSPECIFIED);
            }
            else if (ev.workflowExecutionCanceledEventAttributes) {
                const failure = new common_1.CancelledFailure('Workflow canceled', await (0, internal_non_workflow_1.decodeArrayFromPayloads)(this.dataConverter, ev.workflowExecutionCanceledEventAttributes.details?.payloads));
                failure.stack = '';
                throw new errors_1.WorkflowFailedError('Workflow execution cancelled', failure, common_1.RetryState.RETRY_STATE_NON_RETRYABLE_FAILURE);
            }
            else if (ev.workflowExecutionTerminatedEventAttributes) {
                const failure = new common_1.TerminatedFailure(ev.workflowExecutionTerminatedEventAttributes.reason || 'Workflow execution terminated');
                failure.stack = '';
                throw new errors_1.WorkflowFailedError(ev.workflowExecutionTerminatedEventAttributes.reason || 'Workflow execution terminated', failure, common_1.RetryState.RETRY_STATE_NON_RETRYABLE_FAILURE);
            }
            else if (ev.workflowExecutionTimedOutEventAttributes) {
                if (followRuns && ev.workflowExecutionTimedOutEventAttributes.newExecutionRunId) {
                    execution.runId = ev.workflowExecutionTimedOutEventAttributes.newExecutionRunId;
                    req.nextPageToken = undefined;
                    continue;
                }
                const failure = new common_1.TimeoutFailure('Workflow execution timed out', undefined, common_1.TimeoutType.TIMEOUT_TYPE_START_TO_CLOSE);
                failure.stack = '';
                throw new errors_1.WorkflowFailedError('Workflow execution timed out', failure, ev.workflowExecutionTimedOutEventAttributes.retryState || 0);
            }
            else if (ev.workflowExecutionContinuedAsNewEventAttributes) {
                const { newExecutionRunId } = ev.workflowExecutionContinuedAsNewEventAttributes;
                if (!newExecutionRunId) {
                    throw new TypeError('Expected service to return newExecutionRunId for WorkflowExecutionContinuedAsNewEvent');
                }
                if (!followRuns) {
                    throw new errors_1.WorkflowContinuedAsNewError('Workflow execution continued as new', newExecutionRunId);
                }
                execution.runId = newExecutionRunId;
                req.nextPageToken = undefined;
                continue;
            }
        }
    }
    rethrowGrpcError(err, fallbackMessage, workflowExecution) {
        if ((0, errors_1.isGrpcServiceError)(err)) {
            (0, helpers_1.rethrowKnownErrorTypes)(err);
            if (err.code === grpc_js_1.status.NOT_FOUND) {
                throw new common_1.WorkflowNotFoundError(err.details ?? 'Workflow not found', workflowExecution?.workflowId ?? '', workflowExecution?.runId);
            }
            throw new errors_1.ServiceError(fallbackMessage, { cause: err });
        }
        throw new errors_1.ServiceError('Unexpected error while making gRPC request', { cause: err });
    }
    /**
     * Uses given input to make a queryWorkflow call to the service
     *
     * Used as the final function of the query interceptor chain
     */
    async _queryWorkflowHandler(input) {
        const req = {
            queryRejectCondition: input.queryRejectCondition,
            namespace: this.options.namespace,
            execution: input.workflowExecution,
            query: {
                queryType: input.queryType,
                queryArgs: { payloads: await (0, internal_non_workflow_1.encodeToPayloads)(this.dataConverter, ...input.args) },
                header: { fields: input.headers },
            },
        };
        let response;
        try {
            response = await this.workflowService.queryWorkflow(req);
        }
        catch (err) {
            if ((0, errors_1.isGrpcServiceError)(err)) {
                (0, helpers_1.rethrowKnownErrorTypes)(err);
                if (err.code === grpc_js_1.status.INVALID_ARGUMENT) {
                    throw new QueryNotRegisteredError(err.message.replace(/^3 INVALID_ARGUMENT: /, ''), err.code);
                }
            }
            this.rethrowGrpcError(err, 'Failed to query Workflow', input.workflowExecution);
        }
        if (response.queryRejected) {
            if (response.queryRejected.status === undefined || response.queryRejected.status === null) {
                throw new TypeError('Received queryRejected from server with no status');
            }
            throw new QueryRejectedError(response.queryRejected.status);
        }
        if (!response.queryResult) {
            throw new TypeError('Invalid response from server');
        }
        // We ignore anything but the first result
        return await (0, internal_non_workflow_1.decodeFromPayloadsAtIndex)(this.dataConverter, 0, response.queryResult?.payloads);
    }
    /**
     * Uses given input to make a signalWorkflowExecution call to the service
     *
     * Used as the final function of the signal interceptor chain
     */
    async _signalWorkflowHandler(input) {
        const req = {
            identity: this.options.identity,
            namespace: this.options.namespace,
            workflowExecution: input.workflowExecution,
            requestId: (0, uuid_1.v4)(),
            // control is unused,
            signalName: input.signalName,
            header: { fields: input.headers },
            input: { payloads: await (0, internal_non_workflow_1.encodeToPayloads)(this.dataConverter, ...input.args) },
        };
        try {
            await this.workflowService.signalWorkflowExecution(req);
        }
        catch (err) {
            this.rethrowGrpcError(err, 'Failed to signal Workflow', input.workflowExecution);
        }
    }
    /**
     * Uses given input to make a signalWithStartWorkflowExecution call to the service
     *
     * Used as the final function of the signalWithStart interceptor chain
     */
    async _signalWithStartWorkflowHandler(input) {
        const { identity } = this.options;
        const { options, workflowType, signalName, signalArgs, headers } = input;
        const req = {
            namespace: this.options.namespace,
            identity,
            requestId: (0, uuid_1.v4)(),
            workflowId: options.workflowId,
            workflowIdReusePolicy: options.workflowIdReusePolicy,
            workflowType: { name: workflowType },
            input: { payloads: await (0, internal_non_workflow_1.encodeToPayloads)(this.dataConverter, ...options.args) },
            signalName,
            signalInput: { payloads: await (0, internal_non_workflow_1.encodeToPayloads)(this.dataConverter, ...signalArgs) },
            taskQueue: {
                kind: proto_1.temporal.api.enums.v1.TaskQueueKind.TASK_QUEUE_KIND_UNSPECIFIED,
                name: options.taskQueue,
            },
            workflowExecutionTimeout: options.workflowExecutionTimeout,
            workflowRunTimeout: options.workflowRunTimeout,
            workflowTaskTimeout: options.workflowTaskTimeout,
            retryPolicy: options.retry ? (0, common_1.compileRetryPolicy)(options.retry) : undefined,
            memo: options.memo ? { fields: await (0, internal_non_workflow_1.encodeMapToPayloads)(this.dataConverter, options.memo) } : undefined,
            searchAttributes: options.searchAttributes
                ? {
                    indexedFields: (0, common_1.mapToPayloads)(common_1.searchAttributePayloadConverter, options.searchAttributes),
                }
                : undefined,
            cronSchedule: options.cronSchedule,
            header: { fields: headers },
        };
        try {
            return (await this.workflowService.signalWithStartWorkflowExecution(req)).runId;
        }
        catch (err) {
            if (err.code === grpc_js_1.status.ALREADY_EXISTS) {
                throw new common_1.WorkflowExecutionAlreadyStartedError('Workflow execution already started', options.workflowId, workflowType);
            }
            this.rethrowGrpcError(err, 'Failed to signalWithStart Workflow', { workflowId: options.workflowId });
        }
    }
    /**
     * Uses given input to make startWorkflowExecution call to the service
     *
     * Used as the final function of the start interceptor chain
     */
    async _startWorkflowHandler(input) {
        const { options: opts, workflowType, headers } = input;
        const { identity } = this.options;
        const req = {
            namespace: this.options.namespace,
            identity,
            requestId: (0, uuid_1.v4)(),
            workflowId: opts.workflowId,
            workflowIdReusePolicy: opts.workflowIdReusePolicy,
            workflowType: { name: workflowType },
            input: { payloads: await (0, internal_non_workflow_1.encodeToPayloads)(this.dataConverter, ...opts.args) },
            taskQueue: {
                kind: proto_1.temporal.api.enums.v1.TaskQueueKind.TASK_QUEUE_KIND_UNSPECIFIED,
                name: opts.taskQueue,
            },
            workflowExecutionTimeout: opts.workflowExecutionTimeout,
            workflowRunTimeout: opts.workflowRunTimeout,
            workflowTaskTimeout: opts.workflowTaskTimeout,
            retryPolicy: opts.retry ? (0, common_1.compileRetryPolicy)(opts.retry) : undefined,
            memo: opts.memo ? { fields: await (0, internal_non_workflow_1.encodeMapToPayloads)(this.dataConverter, opts.memo) } : undefined,
            searchAttributes: opts.searchAttributes
                ? {
                    indexedFields: (0, common_1.mapToPayloads)(common_1.searchAttributePayloadConverter, opts.searchAttributes),
                }
                : undefined,
            cronSchedule: opts.cronSchedule,
            header: { fields: headers },
        };
        try {
            return (await this.workflowService.startWorkflowExecution(req)).runId;
        }
        catch (err) {
            if (err.code === grpc_js_1.status.ALREADY_EXISTS) {
                throw new common_1.WorkflowExecutionAlreadyStartedError('Workflow execution already started', opts.workflowId, workflowType);
            }
            this.rethrowGrpcError(err, 'Failed to start Workflow', { workflowId: opts.workflowId });
        }
    }
    /**
     * Uses given input to make terminateWorkflowExecution call to the service
     *
     * Used as the final function of the terminate interceptor chain
     */
    async _terminateWorkflowHandler(input) {
        const req = {
            namespace: this.options.namespace,
            identity: this.options.identity,
            ...input,
            details: {
                payloads: input.details ? await (0, internal_non_workflow_1.encodeToPayloads)(this.dataConverter, ...input.details) : undefined,
            },
            firstExecutionRunId: input.firstExecutionRunId,
        };
        try {
            return await this.workflowService.terminateWorkflowExecution(req);
        }
        catch (err) {
            this.rethrowGrpcError(err, 'Failed to terminate Workflow', input.workflowExecution);
        }
    }
    /**
     * Uses given input to make requestCancelWorkflowExecution call to the service
     *
     * Used as the final function of the cancel interceptor chain
     */
    async _cancelWorkflowHandler(input) {
        try {
            return await this.workflowService.requestCancelWorkflowExecution({
                namespace: this.options.namespace,
                identity: this.options.identity,
                requestId: (0, uuid_1.v4)(),
                workflowExecution: input.workflowExecution,
                firstExecutionRunId: input.firstExecutionRunId,
            });
        }
        catch (err) {
            this.rethrowGrpcError(err, 'Failed to cancel workflow', input.workflowExecution);
        }
    }
    /**
     * Uses given input to make describeWorkflowExecution call to the service
     *
     * Used as the final function of the describe interceptor chain
     */
    async _describeWorkflowHandler(input) {
        try {
            return await this.workflowService.describeWorkflowExecution({
                namespace: this.options.namespace,
                execution: input.workflowExecution,
            });
        }
        catch (err) {
            this.rethrowGrpcError(err, 'Failed to describe workflow', input.workflowExecution);
        }
    }
    /**
     * Create a new workflow handle for new or existing Workflow execution
     */
    _createWorkflowHandle({ workflowId, runId, firstExecutionRunId, interceptors, runIdForResult, ...resultOptions }) {
        return {
            client: this,
            workflowId,
            async result() {
                return this.client.result(workflowId, runIdForResult, resultOptions);
            },
            async terminate(reason) {
                const next = this.client._terminateWorkflowHandler.bind(this.client);
                const fn = interceptors.length ? (0, interceptors_1.composeInterceptors)(interceptors, 'terminate', next) : next;
                return await fn({
                    workflowExecution: { workflowId, runId },
                    reason,
                    firstExecutionRunId,
                });
            },
            async cancel() {
                const next = this.client._cancelWorkflowHandler.bind(this.client);
                const fn = interceptors.length ? (0, interceptors_1.composeInterceptors)(interceptors, 'cancel', next) : next;
                return await fn({
                    workflowExecution: { workflowId, runId },
                    firstExecutionRunId,
                });
            },
            async describe() {
                const next = this.client._describeWorkflowHandler.bind(this.client);
                const fn = interceptors.length ? (0, interceptors_1.composeInterceptors)(interceptors, 'describe', next) : next;
                const raw = await fn({
                    workflowExecution: { workflowId, runId },
                });
                const info = await (0, helpers_1.executionInfoFromRaw)(raw.workflowExecutionInfo ?? {}, this.client.dataConverter, raw);
                return {
                    ...info,
                    raw,
                };
            },
            async fetchHistory() {
                let nextPageToken = undefined;
                const events = Array();
                for (;;) {
                    const response = await this.client.workflowService.getWorkflowExecutionHistory({
                        nextPageToken,
                        namespace: this.client.options.namespace,
                        execution: { workflowId, runId },
                    });
                    events.push(...(response.history?.events ?? []));
                    nextPageToken = response.nextPageToken;
                    if (nextPageToken == null || nextPageToken.length === 0)
                        break;
                }
                return proto_1.temporal.api.history.v1.History.create({ events });
            },
            async signal(def, ...args) {
                const next = this.client._signalWorkflowHandler.bind(this.client);
                const fn = interceptors.length ? (0, interceptors_1.composeInterceptors)(interceptors, 'signal', next) : next;
                await fn({
                    workflowExecution: { workflowId, runId },
                    signalName: typeof def === 'string' ? def : def.name,
                    args,
                    headers: {},
                });
            },
            async query(def, ...args) {
                const next = this.client._queryWorkflowHandler.bind(this.client);
                const fn = interceptors.length ? (0, interceptors_1.composeInterceptors)(interceptors, 'query', next) : next;
                return fn({
                    workflowExecution: { workflowId, runId },
                    queryRejectCondition: this.client.options.queryRejectCondition,
                    queryType: typeof def === 'string' ? def : def.name,
                    args,
                    headers: {},
                });
            },
        };
    }
    /**
     * Create a handle to an existing Workflow.
     *
     * - If only `workflowId` is passed, and there are multiple Workflow Executions with that ID, the handle will refer to
     *   the most recent one.
     * - If `workflowId` and `runId` are passed, the handle will refer to the specific Workflow Execution with that Run
     *   ID.
     * - If `workflowId` and {@link GetWorkflowHandleOptions.firstExecutionRunId} are passed, the handle will refer to the
     *   most recent Workflow Execution in the *Chain* that started with `firstExecutionRunId`.
     *
     * A *Chain* is a series of Workflow Executions that share the same Workflow ID and are connected by:
     * - Being part of the same {@link https://docs.temporal.io/typescript/clients#scheduling-cron-workflows | Cron}
     * - {@link https://docs.temporal.io/typescript/workflows#continueasnew | Continue As New}
     * - {@link https://typescript.temporal.io/api/interfaces/client.workflowoptions/#retry | Retries}
     *
     * This method does not validate `workflowId`. If there is no Workflow Execution with the given `workflowId`, handle
     * methods like `handle.describe()` will throw a {@link WorkflowNotFoundError} error.
     */
    getHandle(workflowId, runId, options) {
        const interceptors = this.getOrMakeInterceptors(workflowId, runId);
        return this._createWorkflowHandle({
            workflowId,
            runId,
            firstExecutionRunId: options?.firstExecutionRunId,
            runIdForResult: runId ?? options?.firstExecutionRunId,
            interceptors,
            followRuns: options?.followRuns ?? true,
        });
    }
    async *_list(options) {
        let nextPageToken = Buffer.alloc(0);
        for (;;) {
            let response;
            try {
                response = await this.workflowService.listWorkflowExecutions({
                    namespace: this.options.namespace,
                    query: options?.query,
                    nextPageToken,
                    pageSize: options?.pageSize,
                });
            }
            catch (e) {
                this.rethrowGrpcError(e, 'Failed to list workflows', undefined);
            }
            // Not decoding memo payloads concurrently even though we could have to keep the lazy nature of this iterator.
            // Decoding is done for `memo` fields which tend to be small.
            // We might decide to change that based on user feedback.
            for (const raw of response.executions) {
                yield await (0, helpers_1.executionInfoFromRaw)(raw, this.dataConverter, raw);
            }
            nextPageToken = response.nextPageToken;
            if (nextPageToken == null || nextPageToken.length === 0)
                break;
        }
    }
    /**
     * List workflows by given `query`.
     *
     * ⚠️ To use advanced query functionality, as of the 1.18 server release, you must use Elasticsearch based visibility.
     *
     * More info on the concept of "visibility" and the query syntax on the Temporal documentation site:
     * https://docs.temporal.io/visibility
     */
    list(options) {
        return {
            [Symbol.asyncIterator]: () => this._list(options)[Symbol.asyncIterator](),
            intoHistories: (intoHistoriesOptions) => {
                return (0, iterators_utils_1.mapAsyncIterable)(this._list(options), async ({ workflowId, runId }) => ({
                    workflowId,
                    history: await this.getHandle(workflowId, runId)
                        .fetchHistory()
                        .catch((_) => undefined),
                }), { concurrency: intoHistoriesOptions?.concurrency ?? 5 });
            },
        };
    }
    getOrMakeInterceptors(workflowId, runId) {
        if (typeof this.options.interceptors === 'object' && 'calls' in this.options.interceptors) {
            // eslint-disable-next-line deprecation/deprecation
            const factories = this.options.interceptors.calls ?? [];
            return factories.map((ctor) => ctor({ workflowId, runId }));
        }
        return Array.isArray(this.options.interceptors) ? this.options.interceptors : [];
    }
}
exports.WorkflowClient = WorkflowClient;
let QueryRejectedError = class QueryRejectedError extends Error {
    constructor(status) {
        super('Query rejected');
        this.status = status;
    }
};
QueryRejectedError = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('QueryRejectedError')
], QueryRejectedError);
exports.QueryRejectedError = QueryRejectedError;
let QueryNotRegisteredError = class QueryNotRegisteredError extends Error {
    constructor(message, code) {
        super(message);
        this.code = code;
    }
};
QueryNotRegisteredError = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('QueryNotRegisteredError')
], QueryNotRegisteredError);
exports.QueryNotRegisteredError = QueryNotRegisteredError;
//# sourceMappingURL=workflow-client.js.map