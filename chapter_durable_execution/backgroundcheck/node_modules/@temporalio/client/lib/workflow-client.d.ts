import { status as grpcStatus } from '@grpc/grpc-js';
import { BaseWorkflowHandle, HistoryAndWorkflowId, QueryDefinition, WithWorkflowArgs, Workflow, WorkflowResultType } from '@temporalio/common';
import { History } from '@temporalio/common/lib/proto-utils';
import { temporal } from '@temporalio/proto';
import { WorkflowCancelInput, WorkflowClientInterceptor, WorkflowClientInterceptors, WorkflowDescribeInput, WorkflowQueryInput, WorkflowSignalInput, WorkflowSignalWithStartInput, WorkflowStartInput, WorkflowTerminateInput } from './interceptors';
import { DescribeWorkflowExecutionResponse, RequestCancelWorkflowExecutionResponse, TerminateWorkflowExecutionResponse, WorkflowExecution, WorkflowExecutionDescription, WorkflowExecutionInfo, WorkflowService } from './types';
import { WorkflowOptions, WorkflowSignalWithStartOptions, WorkflowStartOptions } from './workflow-options';
import { BaseClient, BaseClientOptions, LoadedWithDefaults } from './base-client';
/**
 * A client side handle to a single Workflow instance.
 * It can be used to start, signal, query, wait for completion, terminate and cancel a Workflow execution.
 *
 * Given the following Workflow definition:
 * ```ts
 * export const incrementSignal = defineSignal('increment');
 * export const getValueQuery = defineQuery<number>('getValue');
 * export async function counterWorkflow(initialValue: number): Promise<void>;
 * ```
 *
 * Create a handle for running and interacting with a single Workflow:
 * ```ts
 * const client = new WorkflowClient();
 * // Start the Workflow with initialValue of 2.
 * const handle = await client.start({
 *   workflowType: counterWorkflow,
 *   args: [2],
 *   taskQueue: 'tutorial',
 * });
 * await handle.signal(incrementSignal, 2);
 * await handle.query(getValueQuery); // 4
 * await handle.cancel();
 * await handle.result(); // throws WorkflowExecutionCancelledError
 * ```
 */
export interface WorkflowHandle<T extends Workflow = Workflow> extends BaseWorkflowHandle<T> {
    /**
     * Query a running or completed Workflow.
     *
     * @param def a query definition as returned from {@link defineQuery} or query name (string)
     *
     * @example
     * ```ts
     * await handle.query(getValueQuery);
     * await handle.query<number, []>('getValue');
     * ```
     */
    query<Ret, Args extends any[] = []>(def: QueryDefinition<Ret, Args> | string, ...args: Args): Promise<Ret>;
    /**
     * Terminate a running Workflow
     */
    terminate(reason?: string): Promise<TerminateWorkflowExecutionResponse>;
    /**
     * Cancel a running Workflow.
     *
     * When a Workflow is cancelled, the root scope throws {@link CancelledFailure} with `message: 'Workflow canceled'`.
     * That means that all cancellable scopes will throw `CancelledFailure`.
     *
     * Cancellation may be propagated to Activities depending on {@link ActivityOptions#cancellationType}, after which
     * Activity calls may throw an {@link ActivityFailure}, and `isCancellation(error)` will be true (see {@link isCancellation}).
     *
     * Cancellation may be propagated to Child Workflows depending on {@link ChildWorkflowOptions#cancellationType}, after
     * which calls to {@link executeChild} and {@link ChildWorkflowHandle#result} will throw, and `isCancellation(error)`
     * will be true (see {@link isCancellation}).
     */
    cancel(): Promise<RequestCancelWorkflowExecutionResponse>;
    /**
     * Describe the current workflow execution
     */
    describe(): Promise<WorkflowExecutionDescription>;
    /**
     * Return a workflow execution's history
     */
    fetchHistory(): Promise<History>;
    /**
     * Readonly accessor to the underlying WorkflowClient
     */
    readonly client: WorkflowClient;
}
/**
 * This interface is exactly the same as {@link WorkflowHandle} except it
 * includes the `firstExecutionRunId` returned from {@link WorkflowClient.start}.
 */
export interface WorkflowHandleWithFirstExecutionRunId<T extends Workflow = Workflow> extends WorkflowHandle<T> {
    /**
     * Run Id of the first Execution in the Workflow Execution Chain.
     */
    readonly firstExecutionRunId: string;
}
/**
 * This interface is exactly the same as {@link WorkflowHandle} except it
 * includes the `signaledRunId` returned from `signalWithStart`.
 */
export interface WorkflowHandleWithSignaledRunId<T extends Workflow = Workflow> extends WorkflowHandle<T> {
    /**
     * The Run Id of the bound Workflow at the time of {@link WorkflowClient.signalWithStart}.
     *
     * Since `signalWithStart` may have signaled an existing Workflow Chain, `signaledRunId` might not be the
     * `firstExecutionRunId`.
     */
    readonly signaledRunId: string;
}
export interface WorkflowClientOptions extends BaseClientOptions {
    /**
     * Used to override and extend default Connection functionality
     *
     * Useful for injecting auth headers and tracing Workflow executions
     */
    interceptors?: WorkflowClientInterceptors | WorkflowClientInterceptor[];
    /**
     * Should a query be rejected by closed and failed workflows
     *
     * @default QUERY_REJECT_CONDITION_UNSPECIFIED which means that closed and failed workflows are still queryable
     */
    queryRejectCondition?: temporal.api.enums.v1.QueryRejectCondition;
}
export type LoadedWorkflowClientOptions = LoadedWithDefaults<WorkflowClientOptions>;
/**
 * Options for getting a result of a Workflow execution.
 */
export interface WorkflowResultOptions {
    /**
     * If set to true, instructs the client to follow the chain of execution before returning a Workflow's result.
     *
     * Workflow execution is chained if the Workflow has a cron schedule or continues-as-new or configured to retry
     * after failure or timeout.
     *
     * @default true
     */
    followRuns?: boolean;
}
export interface GetWorkflowHandleOptions extends WorkflowResultOptions {
    /**
     * ID of the first execution in the Workflow execution chain.
     *
     * When getting a handle with no `runId`, pass this option to ensure some
     * {@link WorkflowHandle} methods (e.g. `terminate` and `cancel`) don't
     * affect executions from another chain.
     */
    firstExecutionRunId?: string;
}
interface WorkflowHandleOptions extends GetWorkflowHandleOptions {
    workflowId: string;
    runId?: string;
    interceptors: WorkflowClientInterceptor[];
    /**
     * A runId to use for getting the workflow's result.
     *
     * - When creating a handle using `getHandle`, uses the provided runId or firstExecutionRunId
     * - When creating a handle using `start`, uses the returned runId (first in the chain)
     * - When creating a handle using `signalWithStart`, uses the the returned runId
     */
    runIdForResult?: string;
}
/**
 * An iterable list of WorkflowExecution, as returned by {@link WorkflowClient.list}.
 */
export interface AsyncWorkflowListIterable extends AsyncIterable<WorkflowExecutionInfo> {
    /**
     * Return an iterable of histories corresponding to this iterable's WorkflowExecutions.
     * Workflow histories will be fetched concurrently.
     *
     * Useful in batch replaying
     */
    intoHistories: (intoHistoriesOptions?: IntoHistoriesOptions) => AsyncIterable<HistoryAndWorkflowId>;
}
/**
 * Options for {@link WorkflowClient.list}
 */
export interface ListOptions {
    /**
     * Maximum number of results to fetch per page.
     *
     * @default depends on server config, typically 1000
     */
    pageSize?: number;
    /**
     * Query string for matching and ordering the results
     */
    query?: string;
}
/**
 * Options for {@link WorkflowClient.list().intoHistories()}
 */
export interface IntoHistoriesOptions {
    /**
     * Maximum number of workflow histories to download concurrently.
     *
     * @default 5
     */
    concurrency?: number;
    /**
     * Maximum number of workflow histories to buffer ahead, ready for consumption.
     *
     * It is recommended to set `bufferLimit` to a rasonnably low number if it is expected that the
     * iterable may be stopped before reaching completion (for example, when implementing a fail fast
     * bach replay test).
     *
     * Ignored unless `concurrency > 1`. No limit applies if set to `undefined`.
     *
     * @default unlimited
     */
    bufferLimit?: number;
}
/**
 * Client for starting Workflow executions and creating Workflow handles.
 *
 * Typically this client should not be instantiated directly, instead create the high level {@link Client} and use
 * {@link Client.workflow} to interact with Workflows.
 */
export declare class WorkflowClient extends BaseClient {
    readonly options: LoadedWorkflowClientOptions;
    constructor(options?: WorkflowClientOptions);
    /**
     * Raw gRPC access to the Temporal service.
     *
     * **NOTE**: The namespace provided in {@link options} is **not** automatically set on requests made via this service
     * object.
     */
    get workflowService(): WorkflowService;
    /**
     * Start a new Workflow execution.
     *
     * @returns the execution's `runId`.
     */
    protected _start<T extends Workflow>(workflowTypeOrFunc: string | T, options: WithWorkflowArgs<T, WorkflowOptions>, interceptors: WorkflowClientInterceptor[]): Promise<string>;
    /**
     * Sends a signal to a running Workflow or starts a new one if not already running and immediately signals it.
     * Useful when you're unsure of the Workflows' run state.
     *
     * @returns the runId of the Workflow
     */
    protected _signalWithStart<T extends Workflow, SA extends any[]>(workflowTypeOrFunc: string | T, options: WithWorkflowArgs<T, WorkflowSignalWithStartOptions<SA>>, interceptors: WorkflowClientInterceptor[]): Promise<string>;
    /**
     * Start a new Workflow execution.
     *
     * @returns a WorkflowHandle to the started Workflow
     */
    start<T extends Workflow>(workflowTypeOrFunc: string | T, options: WorkflowStartOptions<T>): Promise<WorkflowHandleWithFirstExecutionRunId<T>>;
    /**
     * Sends a Signal to a running Workflow or starts a new one if not already running and immediately Signals it.
     * Useful when you're unsure whether the Workflow has been started.
     *
     * @returns a {@link WorkflowHandle} to the started Workflow
     */
    signalWithStart<WorkflowFn extends Workflow, SignalArgs extends any[] = []>(workflowTypeOrFunc: string | WorkflowFn, options: WithWorkflowArgs<WorkflowFn, WorkflowSignalWithStartOptions<SignalArgs>>): Promise<WorkflowHandleWithSignaledRunId<WorkflowFn>>;
    /**
     * Starts a new Workflow execution and awaits its completion.
     *
     * @returns the result of the Workflow execution
     */
    execute<T extends Workflow>(workflowTypeOrFunc: string | T, options: WorkflowStartOptions<T>): Promise<WorkflowResultType<T>>;
    /**
     * Gets the result of a Workflow execution.
     *
     * Follows the chain of execution in case Workflow continues as new, or has a cron schedule or retry policy.
     */
    result<T extends Workflow>(workflowId: string, runId?: string, opts?: WorkflowResultOptions): Promise<WorkflowResultType<T>>;
    protected rethrowGrpcError(err: unknown, fallbackMessage: string, workflowExecution?: WorkflowExecution): never;
    /**
     * Uses given input to make a queryWorkflow call to the service
     *
     * Used as the final function of the query interceptor chain
     */
    protected _queryWorkflowHandler(input: WorkflowQueryInput): Promise<unknown>;
    /**
     * Uses given input to make a signalWorkflowExecution call to the service
     *
     * Used as the final function of the signal interceptor chain
     */
    protected _signalWorkflowHandler(input: WorkflowSignalInput): Promise<void>;
    /**
     * Uses given input to make a signalWithStartWorkflowExecution call to the service
     *
     * Used as the final function of the signalWithStart interceptor chain
     */
    protected _signalWithStartWorkflowHandler(input: WorkflowSignalWithStartInput): Promise<string>;
    /**
     * Uses given input to make startWorkflowExecution call to the service
     *
     * Used as the final function of the start interceptor chain
     */
    protected _startWorkflowHandler(input: WorkflowStartInput): Promise<string>;
    /**
     * Uses given input to make terminateWorkflowExecution call to the service
     *
     * Used as the final function of the terminate interceptor chain
     */
    protected _terminateWorkflowHandler(input: WorkflowTerminateInput): Promise<TerminateWorkflowExecutionResponse>;
    /**
     * Uses given input to make requestCancelWorkflowExecution call to the service
     *
     * Used as the final function of the cancel interceptor chain
     */
    protected _cancelWorkflowHandler(input: WorkflowCancelInput): Promise<RequestCancelWorkflowExecutionResponse>;
    /**
     * Uses given input to make describeWorkflowExecution call to the service
     *
     * Used as the final function of the describe interceptor chain
     */
    protected _describeWorkflowHandler(input: WorkflowDescribeInput): Promise<DescribeWorkflowExecutionResponse>;
    /**
     * Create a new workflow handle for new or existing Workflow execution
     */
    protected _createWorkflowHandle<T extends Workflow>({ workflowId, runId, firstExecutionRunId, interceptors, runIdForResult, ...resultOptions }: WorkflowHandleOptions): WorkflowHandle<T>;
    /**
     * Create a handle to an existing Workflow.
     *
     * - If only `workflowId` is passed, and there are multiple Workflow Executions with that ID, the handle will refer to
     *   the most recent one.
     * - If `workflowId` and `runId` are passed, the handle will refer to the specific Workflow Execution with that Run
     *   ID.
     * - If `workflowId` and {@link GetWorkflowHandleOptions.firstExecutionRunId} are passed, the handle will refer to the
     *   most recent Workflow Execution in the *Chain* that started with `firstExecutionRunId`.
     *
     * A *Chain* is a series of Workflow Executions that share the same Workflow ID and are connected by:
     * - Being part of the same {@link https://docs.temporal.io/typescript/clients#scheduling-cron-workflows | Cron}
     * - {@link https://docs.temporal.io/typescript/workflows#continueasnew | Continue As New}
     * - {@link https://typescript.temporal.io/api/interfaces/client.workflowoptions/#retry | Retries}
     *
     * This method does not validate `workflowId`. If there is no Workflow Execution with the given `workflowId`, handle
     * methods like `handle.describe()` will throw a {@link WorkflowNotFoundError} error.
     */
    getHandle<T extends Workflow>(workflowId: string, runId?: string, options?: GetWorkflowHandleOptions): WorkflowHandle<T>;
    protected _list(options?: ListOptions): AsyncIterable<WorkflowExecutionInfo>;
    /**
     * List workflows by given `query`.
     *
     * ⚠️ To use advanced query functionality, as of the 1.18 server release, you must use Elasticsearch based visibility.
     *
     * More info on the concept of "visibility" and the query syntax on the Temporal documentation site:
     * https://docs.temporal.io/visibility
     */
    list(options?: ListOptions): AsyncWorkflowListIterable;
    protected getOrMakeInterceptors(workflowId: string, runId?: string): WorkflowClientInterceptor[];
}
export declare class QueryRejectedError extends Error {
    readonly status: temporal.api.enums.v1.WorkflowExecutionStatus;
    constructor(status: temporal.api.enums.v1.WorkflowExecutionStatus);
}
export declare class QueryNotRegisteredError extends Error {
    readonly code: grpcStatus;
    constructor(message: string, code: grpcStatus);
}
export {};
