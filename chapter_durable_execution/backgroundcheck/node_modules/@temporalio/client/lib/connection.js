"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Connection = exports.LOCAL_TARGET = void 0;
const node_async_hooks_1 = require("node:async_hooks");
const grpc = __importStar(require("@grpc/grpc-js"));
const internal_non_workflow_1 = require("@temporalio/common/lib/internal-non-workflow");
const time_1 = require("@temporalio/common/lib/time");
const errors_1 = require("./errors");
const grpc_retry_1 = require("./grpc-retry");
const pkg_1 = __importDefault(require("./pkg"));
const types_1 = require("./types");
exports.LOCAL_TARGET = '127.0.0.1:7233';
function addDefaults(options) {
    const { channelArgs, interceptors, connectTimeout, ...rest } = options;
    return {
        address: exports.LOCAL_TARGET,
        credentials: grpc.credentials.createInsecure(),
        channelArgs: {
            'grpc.keepalive_permit_without_calls': 1,
            'grpc.keepalive_time_ms': 30000,
            'grpc.keepalive_timeout_ms': 15000,
            ...channelArgs,
        },
        interceptors: interceptors ?? [(0, grpc_retry_1.makeGrpcRetryInterceptor)((0, grpc_retry_1.defaultGrpcRetryOptions)())],
        metadata: {},
        connectTimeoutMs: (0, time_1.msOptionalToNumber)(connectTimeout) ?? 10000,
        ...(0, internal_non_workflow_1.filterNullAndUndefined)(rest),
    };
}
/**
 * - Convert {@link ConnectionOptions.tls} to {@link grpc.ChannelCredentials}
 * - Add the grpc.ssl_target_name_override GRPC {@link ConnectionOptions.channelArgs | channel arg}
 * - Add default port to address if port not specified
 */
function normalizeGRPCConfig(options) {
    const { tls: tlsFromConfig, credentials, ...rest } = options || {};
    if (rest.address) {
        // eslint-disable-next-line prefer-const
        let [host, port] = rest.address.split(':', 2);
        port = port || '7233';
        rest.address = `${host}:${port}`;
    }
    const tls = (0, internal_non_workflow_1.normalizeTlsConfig)(tlsFromConfig);
    if (tls) {
        if (credentials) {
            throw new TypeError('Both `tls` and `credentials` ConnectionOptions were provided');
        }
        return {
            ...rest,
            credentials: grpc.credentials.createSsl(tls.serverRootCACertificate, tls.clientCertPair?.key, tls.clientCertPair?.crt),
            channelArgs: {
                ...rest.channelArgs,
                ...(tls.serverNameOverride
                    ? {
                        'grpc.ssl_target_name_override': tls.serverNameOverride,
                        'grpc.default_authority': tls.serverNameOverride,
                    }
                    : undefined),
            },
        };
    }
    else {
        return rest;
    }
}
/**
 * Client connection to the Temporal Server
 *
 * ⚠️ Connections are expensive to construct and should be reused. Make sure to {@link close} any unused connections to
 * avoid leaking resources.
 */
class Connection {
    static createCtorOptions(options) {
        var _a, _b;
        const optionsWithDefaults = addDefaults(normalizeGRPCConfig(options));
        // Allow overriding this
        (_a = optionsWithDefaults.metadata)['client-name'] ?? (_a['client-name'] = 'temporal-typescript');
        (_b = optionsWithDefaults.metadata)['client-version'] ?? (_b['client-version'] = pkg_1.default.version);
        const client = new this.Client(optionsWithDefaults.address, optionsWithDefaults.credentials, optionsWithDefaults.channelArgs);
        const callContextStorage = new node_async_hooks_1.AsyncLocalStorage();
        const workflowRpcImpl = this.generateRPCImplementation({
            serviceName: 'temporal.api.workflowservice.v1.WorkflowService',
            client,
            callContextStorage,
            interceptors: optionsWithDefaults?.interceptors,
            staticMetadata: optionsWithDefaults.metadata,
        });
        const workflowService = types_1.WorkflowService.create(workflowRpcImpl, false, false);
        const operatorRpcImpl = this.generateRPCImplementation({
            serviceName: 'temporal.api.operatorservice.v1.OperatorService',
            client,
            callContextStorage,
            interceptors: optionsWithDefaults?.interceptors,
            staticMetadata: optionsWithDefaults.metadata,
        });
        const operatorService = types_1.OperatorService.create(operatorRpcImpl, false, false);
        const healthRpcImpl = this.generateRPCImplementation({
            serviceName: 'grpc.health.v1.Health',
            client,
            callContextStorage,
            interceptors: optionsWithDefaults?.interceptors,
            staticMetadata: optionsWithDefaults.metadata,
        });
        const healthService = types_1.HealthService.create(healthRpcImpl, false, false);
        return {
            client,
            callContextStorage,
            workflowService,
            operatorService,
            healthService,
            options: optionsWithDefaults,
        };
    }
    /**
     * Ensure connection can be established.
     *
     * Does not need to be called if you use {@link connect}.
     *
     * This method's result is memoized to ensure it runs only once.
     *
     * Calls {@link proto.temporal.api.workflowservice.v1.WorkflowService.getSystemInfo} internally.
     */
    async ensureConnected() {
        if (this.connectPromise == null) {
            const deadline = Date.now() + this.options.connectTimeoutMs;
            this.connectPromise = (async () => {
                await this.untilReady(deadline);
                try {
                    await this.withDeadline(deadline, () => this.workflowService.getSystemInfo({}));
                }
                catch (err) {
                    if ((0, errors_1.isGrpcServiceError)(err)) {
                        // Ignore old servers
                        if (err.code !== grpc.status.UNIMPLEMENTED) {
                            throw new errors_1.ServiceError('Failed to connect to Temporal server', { cause: err });
                        }
                    }
                    else {
                        throw err;
                    }
                }
            })();
        }
        return this.connectPromise;
    }
    /**
     * Create a lazy `Connection` instance.
     *
     * This method does not verify connectivity with the server. We recommend using {@link connect} instead.
     */
    static lazy(options) {
        return new this(this.createCtorOptions(options));
    }
    /**
     * Establish a connection with the server and return a `Connection` instance.
     *
     * This is the preferred method of creating connections as it verifies connectivity by calling
     * {@link ensureConnected}.
     */
    static async connect(options) {
        const conn = this.lazy(options);
        await conn.ensureConnected();
        return conn;
    }
    constructor({ options, client, workflowService, operatorService, healthService, callContextStorage, }) {
        this.options = options;
        this.client = client;
        this.workflowService = workflowService;
        this.operatorService = operatorService;
        this.healthService = healthService;
        this.callContextStorage = callContextStorage;
    }
    static generateRPCImplementation({ serviceName, client, callContextStorage, interceptors, staticMetadata, }) {
        return (method, requestData, callback) => {
            const metadataContainer = new grpc.Metadata();
            const { metadata, deadline } = callContextStorage.getStore() ?? {};
            for (const [k, v] of Object.entries(staticMetadata)) {
                metadataContainer.set(k, v);
            }
            if (metadata != null) {
                for (const [k, v] of Object.entries(metadata)) {
                    metadataContainer.set(k, v);
                }
            }
            return client.makeUnaryRequest(`/${serviceName}/${method.name}`, (arg) => arg, (arg) => arg, requestData, metadataContainer, { interceptors, deadline }, callback);
        };
    }
    /**
     * Set the deadline for any service requests executed in `fn`'s scope.
     *
     * @returns value returned from `fn`
     */
    async withDeadline(deadline, fn) {
        const cc = this.callContextStorage.getStore();
        return await this.callContextStorage.run({ deadline, metadata: cc?.metadata }, fn);
    }
    /**
     * Set metadata for any service requests executed in `fn`'s scope.
     *
     * The provided metadata is merged on top of any existing metadata in current scope, including metadata provided in
     * {@link ConnectionOptions.metadata}.
     *
     * @returns value returned from `fn`
     *
     * @example
     *
     *```ts
     *const workflowHandle = await conn.withMetadata({ apiKey: 'secret' }, () =>
     *  conn.withMetadata({ otherKey: 'set' }, () => client.start(options)))
     *);
     *```
     */
    async withMetadata(metadata, fn) {
        const cc = this.callContextStorage.getStore();
        metadata = { ...cc?.metadata, ...metadata };
        return await this.callContextStorage.run({ metadata, deadline: cc?.deadline }, fn);
    }
    /**
     * Wait for successful connection to the server.
     *
     * @see https://grpc.github.io/grpc/node/grpc.Client.html#waitForReady__anchor
     */
    async untilReady(deadline) {
        return new Promise((resolve, reject) => {
            this.client.waitForReady(deadline, (err) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve();
                }
            });
        });
    }
    // This method is async for uniformity with NativeConnection which could be used in the future to power clients
    /**
     * Close the underlying gRPC client.
     *
     * Make sure to call this method to ensure proper resource cleanup.
     */
    async close() {
        this.client.close();
    }
}
exports.Connection = Connection;
/**
 * @internal
 */
Connection.Client = grpc.makeGenericClientConstructor({}, 'WorkflowService', {});
//# sourceMappingURL=connection.js.map