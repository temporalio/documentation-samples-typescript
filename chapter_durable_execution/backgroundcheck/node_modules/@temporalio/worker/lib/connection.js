"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InternalNativeConnection = exports.extractReferenceHolders = exports.extractNativeClient = exports.NativeConnection = void 0;
const node_util_1 = __importDefault(require("node:util"));
const common_1 = require("@temporalio/common");
const core_bridge_1 = require("@temporalio/core-bridge");
const runtime_1 = require("./runtime");
const updateHeaders = node_util_1.default.promisify(core_bridge_1.clientUpdateHeaders);
/**
 * A Native Connection object that delegates calls to the Rust Core binary extension.
 *
 * A Worker must use this class to connect to the server.
 *
 * Do not confuse this connection class with `@temporalio/client`'s Connection.
 */
class NativeConnection {
    /**
     * nativeClient is intentionally left private, framework code can access it with `extractNativeClient` (below)
     */
    constructor(nativeClient) {
        this.nativeClient = nativeClient;
        /**
         * referenceHolders is used internally by the framework, it can be accessed with `extractReferenceHolders` (below)
         */
        this.referenceHolders = new Set();
    }
    /**
     * @deprecated use `connect` instead
     */
    static async create(options) {
        try {
            const client = await runtime_1.Runtime.instance().createNativeClient(options);
            return new this(client);
        }
        catch (err) {
            if (err instanceof core_bridge_1.TransportError) {
                throw new core_bridge_1.TransportError(err.message);
            }
            throw err;
        }
    }
    /**
     * Eagerly connect to the Temporal server and return a NativeConnection instance
     */
    static async connect(options) {
        try {
            const client = await runtime_1.Runtime.instance().createNativeClient(options);
            return new this(client);
        }
        catch (err) {
            if (err instanceof core_bridge_1.TransportError) {
                throw new core_bridge_1.TransportError(err.message);
            }
            throw err;
        }
    }
    /**
     * Close this connection.
     *
     * Make sure any Workers using this connection are stopped before calling
     * this method or it will throw an {@link IllegalStateError}
     */
    async close() {
        if (this.referenceHolders.size > 0) {
            throw new common_1.IllegalStateError('Cannot close connection while Workers hold a reference to it');
        }
        await runtime_1.Runtime.instance().closeNativeClient(this.nativeClient);
    }
    /**
     * Mapping of gRPC metadata (HTTP headers) to send with each request to the server.
     *
     * Use {@link NativeConnectionOptions.metadata} to set the initial metadata for client creation.
     */
    async setMetadata(metadata) {
        await updateHeaders(this.nativeClient, metadata);
    }
}
exports.NativeConnection = NativeConnection;
/**
 * Extract the private native client instance from a `NativeConnection` instance.
 *
 * Only meant to be used by the framework.
 */
function extractNativeClient(conn) {
    return conn.nativeClient;
}
exports.extractNativeClient = extractNativeClient;
/**
 * Extract the private referenceHolders set from a `NativeConnection` instance.
 *
 * Only meant to be used by the framework.
 */
function extractReferenceHolders(conn) {
    return conn.referenceHolders;
}
exports.extractReferenceHolders = extractReferenceHolders;
/**
 * Internal class used when a Worker directly instantiates a connection with no external references.
 *
 * This class is only used as a "marker" during Worker shutdown to decide whether to close the connection.
 */
class InternalNativeConnection extends NativeConnection {
}
exports.InternalNativeConnection = InternalNativeConnection;
//# sourceMappingURL=connection.js.map