"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActivityInboundLogInterceptor = exports.activityLogAttributes = void 0;
const activity_1 = require("@temporalio/activity");
const common_1 = require("@temporalio/common");
const type_helpers_1 = require("@temporalio/common/lib/type-helpers");
const UNINITIALIZED = Symbol('UNINITIALIZED');
/**
 * Returns a map of attributes to be set on log messages for a given Activity
 */
function activityLogAttributes(info) {
    return {
        isLocal: info.isLocal,
        attempt: info.attempt,
        namespace: info.workflowNamespace,
        taskToken: info.base64TaskToken,
        workflowId: info.workflowExecution.workflowId,
        workflowRunId: info.workflowExecution.runId,
        workflowType: info.workflowType,
        activityId: info.activityId,
        activityType: info.activityType,
        taskQueue: info.taskQueue,
    };
}
exports.activityLogAttributes = activityLogAttributes;
/** Logs Activity execution starts and their completions */
class ActivityInboundLogInterceptor {
    constructor(ctx, logger) {
        this.ctx = ctx;
        // If a parent logger was explicitly provided on this interceptor, then use it.
        // Otherwise, use the logger that is already set on the activity context.
        // By default, that will be Runtime.logger, but another interceptor might have overriden it,
        // in which case we would want to use that one as our parent logger.
        const parentLogger = logger ?? ctx.log;
        this.logger = parentLogger; // eslint-disable-line deprecation/deprecation
        this.ctx.log = Object.fromEntries(['trace', 'debug', 'info', 'warn', 'error'].map((level) => {
            return [
                level,
                (message, attrs) => {
                    return parentLogger[level](message, {
                        ...this.logAttributes(),
                        ...attrs,
                    });
                },
            ];
        }));
    }
    logAttributes() {
        return activityLogAttributes(this.ctx.info);
    }
    async execute(input, next) {
        let error = UNINITIALIZED; // In case someone decides to throw undefined...
        const startTime = process.hrtime.bigint();
        this.ctx.log.debug('Activity started');
        try {
            return await next(input);
        }
        catch (err) {
            error = err;
            throw err;
        }
        finally {
            const durationNanos = process.hrtime.bigint() - startTime;
            const durationMs = Number(durationNanos / 1000000n);
            if (error === UNINITIALIZED) {
                this.ctx.log.debug('Activity completed', { durationMs });
            }
            else if ((error instanceof common_1.CancelledFailure || (0, type_helpers_1.isAbortError)(error)) && this.ctx.cancellationSignal.aborted) {
                this.ctx.log.debug('Activity completed as cancelled', { durationMs });
            }
            else if (error instanceof activity_1.CompleteAsyncError) {
                this.ctx.log.debug('Activity will complete asynchronously', { durationMs });
            }
            else {
                this.ctx.log.warn('Activity failed', { error, durationMs });
            }
        }
    }
}
exports.ActivityInboundLogInterceptor = ActivityInboundLogInterceptor;
//# sourceMappingURL=activity-log-interceptor.js.map