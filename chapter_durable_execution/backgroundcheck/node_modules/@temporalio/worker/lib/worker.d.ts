/// <reference types="node" />
import { EventEmitter } from 'node:events';
import * as otel from '@opentelemetry/api';
import { BehaviorSubject, MonoTypeOperatorFunction, Observable, OperatorFunction, Subject } from 'rxjs';
import { Info as ActivityInfo } from '@temporalio/activity';
import { DataConverter, defaultPayloadConverter } from '@temporalio/common';
import * as native from '@temporalio/core-bridge';
import { coresdk } from '@temporalio/proto';
import { SinkCall } from '@temporalio/workflow';
import { NativeConnection } from './connection';
import { Logger } from './logger';
import { ReplayHistoriesIterable, ReplayResult } from './replay';
import { History, Runtime } from './runtime';
import { CompiledWorkerOptions, ReplayWorkerOptions, WorkerOptions } from './worker-options';
import { WorkflowCodecRunner } from './workflow-codec-runner';
import { WorkflowCreator } from './workflow/interface';
import { WorkflowBundleWithSourceMapAndFilename } from './workflow/workflow-worker-thread/input';
export { DataConverter, defaultPayloadConverter };
/**
 * The worker's possible states
 * * `INITIALIZED` - The initial state of the Worker after calling {@link Worker.create} and successful connection to the server
 * * `RUNNING` - {@link Worker.run} was called, polling task queues
 * * `STOPPING` - {@link Worker.shutdown} was called or received shutdown signal, worker will forcefully shutdown in {@link WorkerOptions.shutdownGraceTime | shutdownGraceTime}
 * * `DRAINING` - Core has indicated that shutdown is complete and all Workflow tasks have been drained, waiting for activities and cached workflows eviction
 * * `DRAINED` - All activities and workflows have completed, ready to shutdown
 * * `STOPPED` - Shutdown complete, {@link Worker.run} resolves
 * * `FAILED` - Worker encountered an unrecoverable error, {@link Worker.run} should reject with the error
 */
export type State = 'INITIALIZED' | 'RUNNING' | 'STOPPED' | 'STOPPING' | 'DRAINING' | 'DRAINED' | 'FAILED';
type ExtractToPromise<T> = T extends (err: any, result: infer R) => void ? Promise<R> : never;
type Last<T extends any[]> = T extends [...infer _I, infer L] ? L : never;
type LastParameter<F extends (...args: any) => any> = Last<Parameters<F>>;
type OmitFirst<T> = T extends [any, ...infer REST] ? REST : never;
type OmitLast<T> = T extends [...infer REST, any] ? REST : never;
type OmitFirstParam<T> = T extends (...args: any[]) => any ? (...args: OmitFirst<Parameters<T>>) => ReturnType<T> : never;
type Promisify<T> = T extends (...args: any[]) => void ? (...args: OmitLast<Parameters<T>>) => ExtractToPromise<LastParameter<T>> : never;
type ContextAware<T> = T & {
    parentSpan: otel.Span;
};
export type ActivationWithContext = ContextAware<{
    activation: coresdk.workflow_activation.WorkflowActivation;
}>;
export type ActivityTaskWithContext = ContextAware<{
    task: coresdk.activity_task.ActivityTask;
    base64TaskToken: string;
}>;
type CompiledWorkerOptionsWithBuildId = CompiledWorkerOptions & {
    buildId: string;
};
/**
 * Combined error information for {@link Worker.runUntil}
 */
export interface CombinedWorkerRunErrorCause {
    /**
     * Error thrown by a Worker
     */
    workerError: unknown;
    /**
     * Error thrown by the wrapped promise or function
     */
    innerError: unknown;
}
/**
 * Error thrown by {@link Worker.runUntil} and {@link Worker.runReplayHistories}
 */
export declare class CombinedWorkerRunError extends Error {
    readonly cause: CombinedWorkerRunErrorCause;
    constructor(message: string, { cause }: {
        cause: CombinedWorkerRunErrorCause;
    });
}
export interface NativeWorkerLike {
    type: 'Worker';
    initiateShutdown: Promisify<OmitFirstParam<typeof native.workerInitiateShutdown>>;
    finalizeShutdown(): Promise<void>;
    flushCoreLogs(): void;
    pollWorkflowActivation: Promisify<OmitFirstParam<typeof native.workerPollWorkflowActivation>>;
    pollActivityTask: Promisify<OmitFirstParam<typeof native.workerPollActivityTask>>;
    completeWorkflowActivation: Promisify<OmitFirstParam<typeof native.workerCompleteWorkflowActivation>>;
    completeActivityTask: Promisify<OmitFirstParam<typeof native.workerCompleteActivityTask>>;
    recordActivityHeartbeat: OmitFirstParam<typeof native.workerRecordActivityHeartbeat>;
    logger: Logger;
}
export interface NativeReplayHandle {
    worker: NativeWorkerLike;
    historyPusher: native.HistoryPusher;
}
export interface WorkerConstructor {
    create(connection: NativeConnection, options: CompiledWorkerOptionsWithBuildId): Promise<NativeWorkerLike>;
    createReplay(options: CompiledWorkerOptionsWithBuildId): Promise<NativeReplayHandle>;
}
export declare class NativeWorker implements NativeWorkerLike {
    protected readonly runtime: Runtime;
    protected readonly nativeWorker: native.Worker;
    readonly type = "Worker";
    readonly pollWorkflowActivation: Promisify<OmitFirstParam<typeof native.workerPollWorkflowActivation>>;
    readonly pollActivityTask: Promisify<OmitFirstParam<typeof native.workerPollActivityTask>>;
    readonly completeWorkflowActivation: Promisify<OmitFirstParam<typeof native.workerCompleteWorkflowActivation>>;
    readonly completeActivityTask: Promisify<OmitFirstParam<typeof native.workerCompleteActivityTask>>;
    readonly recordActivityHeartbeat: OmitFirstParam<typeof native.workerRecordActivityHeartbeat>;
    readonly initiateShutdown: Promisify<OmitFirstParam<typeof native.workerInitiateShutdown>>;
    static create(connection: NativeConnection, options: CompiledWorkerOptionsWithBuildId): Promise<NativeWorkerLike>;
    static createReplay(options: CompiledWorkerOptionsWithBuildId): Promise<NativeReplayHandle>;
    protected constructor(runtime: Runtime, nativeWorker: native.Worker);
    flushCoreLogs(): void;
    finalizeShutdown(): Promise<void>;
    get logger(): Logger;
}
/**
 * Notify that an activity has started, used as input to {@link Worker.activityHeartbeatSubject}
 *
 * Used to detect rogue activities.
 */
interface HeartbeatCreateNotification {
    type: 'create';
    base64TaskToken: string;
}
/**
 * Heartbeat request used as input to {@link Worker.activityHeartbeatSubject}
 */
interface Heartbeat {
    type: 'heartbeat';
    info: ActivityInfo;
    base64TaskToken: string;
    taskToken: Uint8Array;
    details?: any;
    onError: () => void;
}
/**
 * Notifies that an activity has been complete, used as input to {@link Worker.activityHeartbeatSubject}
 */
interface ActivityCompleteNotification {
    type: 'completion';
    flushRequired: boolean;
    callback(): void;
    base64TaskToken: string;
}
/**
 * Notifies that an Activity heartbeat has been flushed, used as input to {@link Worker.activityHeartbeatSubject}
 */
interface HeartbeatFlushNotification {
    type: 'flush';
    base64TaskToken: string;
}
/**
 * Input for the {@link Worker.activityHeartbeatSubject}
 */
type HeartbeatInput = Heartbeat | ActivityCompleteNotification | HeartbeatFlushNotification | HeartbeatCreateNotification;
export type PollerState = 'POLLING' | 'SHUTDOWN' | 'FAILED';
/**
 * Status overview of a Worker.
 * Useful for troubleshooting issues and overall obeservability.
 */
export interface WorkerStatus {
    /**
     * General run state of a Worker
     */
    runState: State;
    /**
     * General state of the Workflow poller
     */
    workflowPollerState: PollerState;
    /**
     * General state of the Activity poller
     */
    activityPollerState: PollerState;
    /**
     * Whether this Worker has an outstanding Workflow poll request
     */
    hasOutstandingWorkflowPoll: boolean;
    /**
     * Whether this Worker has an outstanding Activity poll request
     */
    hasOutstandingActivityPoll: boolean;
    /**
     * Number of in-flight (currently actively processed) Workflow activations
     */
    numInFlightWorkflowActivations: number;
    /**
     * Number of in-flight (currently actively processed) Activities
     */
    numInFlightActivities: number;
    /**
     * Number of Workflow executions cached in Worker memory
     */
    numCachedWorkflows: number;
    /**
     * Number of running Activities that have emitted a heartbeat
     */
    numHeartbeatingActivities: number;
}
/**
 * The temporal Worker connects to Temporal Server and runs Workflows and Activities.
 */
export declare class Worker {
    protected readonly nativeWorker: NativeWorkerLike;
    /**
     * Optional WorkflowCreator - if not provided, Worker will not poll on Workflows
     */
    protected readonly workflowCreator: WorkflowCreator | undefined;
    readonly options: CompiledWorkerOptions;
    protected readonly connection?: NativeConnection | undefined;
    protected readonly isReplayWorker: boolean;
    protected readonly activityHeartbeatSubject: Subject<HeartbeatInput>;
    protected readonly unexpectedErrorSubject: Subject<void>;
    protected readonly stateSubject: BehaviorSubject<State>;
    protected readonly workflowPollerStateSubject: BehaviorSubject<PollerState>;
    protected readonly activityPollerStateSubject: BehaviorSubject<PollerState>;
    /**
     * Whether or not this worker has an outstanding workflow poll request
     */
    protected hasOutstandingWorkflowPoll: boolean;
    /**
     * Whether or not this worker has an outstanding activity poll request
     */
    protected hasOutstandingActivityPoll: boolean;
    protected readonly numInFlightActivationsSubject: BehaviorSubject<number>;
    protected readonly numInFlightActivitiesSubject: BehaviorSubject<number>;
    protected readonly numCachedWorkflowsSubject: BehaviorSubject<number>;
    protected readonly numHeartbeatingActivitiesSubject: BehaviorSubject<number>;
    protected readonly evictionsEmitter: EventEmitter;
    private readonly runIdsToSpanContext;
    protected static nativeWorkerCtor: WorkerConstructor;
    protected static replayWorkerCount: number;
    private static readonly SELF_INDUCED_SHUTDOWN_EVICTION;
    protected readonly tracer: otel.Tracer;
    protected readonly workflowCodecRunner: WorkflowCodecRunner;
    /**
     * Create a new Worker.
     * This method initiates a connection to the server and will throw (asynchronously) on connection failure.
     */
    static create(options: WorkerOptions): Promise<Worker>;
    protected static createWorkflowCreator(workflowBundle: WorkflowBundleWithSourceMapAndFilename, compiledOptions: CompiledWorkerOptions): Promise<WorkflowCreator>;
    /**
     * Create a replay Worker, and run the provided history against it. Will resolve as soon as
     * the history has finished being replayed, or if the workflow produces a nondeterminism error.
     *
     * @param workflowId If provided, use this as the workflow id during replay. Histories do not
     * contain a workflow id, so it must be provided separately if your workflow depends on it.
     * @throws {@link DeterminismViolationError} if the workflow code is not compatible with the history.
     * @throws {@link ReplayError} on any other replay related error.
     */
    static runReplayHistory(options: ReplayWorkerOptions, history: History | unknown, workflowId?: string): Promise<void>;
    /**
     * Create a replay Worker, running all histories provided by the passed in iterable.
     *
     * Returns an async iterable of results for each history replayed.
     */
    static runReplayHistories(options: ReplayWorkerOptions, histories: ReplayHistoriesIterable): AsyncIterableIterator<ReplayResult>;
    private static validateHistory;
    private static constructReplayWorker;
    protected static getOrCreateBundle(compiledOptions: CompiledWorkerOptions, logger: Logger): Promise<WorkflowBundleWithSourceMapAndFilename | undefined>;
    /**
     * Create a new Worker from nativeWorker.
     */
    protected constructor(nativeWorker: NativeWorkerLike, 
    /**
     * Optional WorkflowCreator - if not provided, Worker will not poll on Workflows
     */
    workflowCreator: WorkflowCreator | undefined, options: CompiledWorkerOptions, connection?: NativeConnection | undefined, isReplayWorker?: boolean);
    /**
     * An Observable which emits each time the number of in flight activations changes
     */
    get numInFlightActivations$(): Observable<number>;
    /**
     * An Observable which emits each time the number of in flight Activity tasks changes
     */
    get numInFlightActivities$(): Observable<number>;
    /**
     * An Observable which emits each time the number of cached workflows changes
     */
    get numRunningWorkflowInstances$(): Observable<number>;
    protected get log(): Logger;
    /**
     * Get the poll state of this worker
     */
    getState(): State;
    /**
     * Get a status overview of this Worker
     */
    getStatus(): WorkerStatus;
    protected get state(): State;
    protected set state(state: State);
    /**
     * Start shutting down the Worker. The Worker stops polling for new tasks and sends
     * {@link https://typescript.temporal.io/api/namespaces/activity#cancellation | cancellation} (via a
     * {@link CancelledFailure} with `message` set to `'WORKER_SHUTDOWN'`) to running Activities. Note: if the Activity
     * accepts cancellation (i.e. re-throws or allows the `CancelledFailure` to be thrown out of the Activity function),
     * the Activity Task will be marked as failed, not cancelled. It's helpful for the Activity Task to be marked failed
     * during shutdown because the Server will retry the Activity sooner (than if the Server had to wait for the Activity
     * Task to time out).
     *
     * When called, immediately transitions {@link state} to `'STOPPING'` and asks Core to shut down. Once Core has
     * confirmed that it's shutting down, the Worker enters `'DRAINING'` state unless the Worker has already been
     * `'DRAINED'`. Once all currently running Activities and Workflow Tasks have completed, the Worker transitions to
     * `'STOPPED'`.
     */
    shutdown(): void;
    /**
     * An observable that completes when {@link state} becomes `'DRAINED'` or throws if {@link state} transitions to
     * `'STOPPING'` and remains that way for {@link this.options.shutdownForceTimeMs}.
     */
    protected forceShutdown$(): Observable<never>;
    /**
     * An observable which repeatedly polls for new tasks unless worker becomes suspended.
     * The observable stops emitting once core is shutting down.
     */
    protected pollLoop$<T>(pollFn: () => Promise<T>): Observable<T>;
    /**
     * Process Activity tasks
     */
    protected activityOperator(): OperatorFunction<ActivityTaskWithContext, ContextAware<{
        completion: Uint8Array;
    }>>;
    /**
     * Process Workflow activations
     */
    protected workflowOperator(): OperatorFunction<ActivationWithContext, ContextAware<{
        completion: Uint8Array;
    }>>;
    /**
     * Process extracted external calls from Workflow post activation.
     *
     * Each SinkCall is translated into a injected sink function call.
     *
     * This function does not throw, it will log in case of missing sinks
     * or failed sink function invocations.
     */
    protected processSinkCalls(externalCalls: SinkCall[], isReplaying: boolean): Promise<void>;
    /**
     * Listen on heartbeats emitted from activities and send them to core.
     * Errors from core responses are translated to cancellation requests and fed back via the activityFeedbackSubject.
     */
    protected activityHeartbeat$(): Observable<void>;
    /**
     * Poll core for `WorkflowActivation`s while respecting worker state.
     */
    protected workflowPoll$(): Observable<ActivationWithContext>;
    /**
     * Given a run ID, some jobs from a new WFT, and the parent span or the workflow activation,
     * handle linking any span context that exists in the WF headers to our internal spans.
     *
     * The result here is that our SDK spans in node and core are separate from the user's spans
     * that they create when they use interceptors, with our spans being linked to theirs.
     *
     * If the activation includes WF start, headers will be extracted and cached. If it does not,
     * any previously such extracted header will be used for the run.
     */
    private linkWorkflowSpans;
    /**
     * Poll for Workflow activations, handle them, and report completions.
     */
    protected workflow$(): Observable<void>;
    /**
     * Poll core for `ActivityTask`s while respecting worker state
     */
    protected activityPoll$(): Observable<ActivityTaskWithContext>;
    protected activity$(): Observable<void>;
    protected takeUntilState<T>(state: State): MonoTypeOperatorFunction<T>;
    /**
     * Run the Worker until `fnOrPromise` completes. Then {@link shutdown} and wait for {@link run} to complete.
     *
     * @returns the result of `fnOrPromise`
     *
     * Throws on fatal Worker errors.
     *
     * **SDK versions `< 1.5.0`**:
     * This method would not wait for worker to complete shutdown if the inner `fnOrPromise` threw an error.
     *
     * **SDK versions `>=1.5.0`**:
     * This method always waits for both worker shutdown and inner `fnOrPromise` to resolve.
     * If one of worker run -or- the inner promise throw an error, that error is rethrown.
     * If both throw an error, a {@link CombinedWorkerRunError} with a `cause` attribute containing both errors.
     */
    runUntil<R>(fnOrPromise: Promise<R> | (() => Promise<R>)): Promise<R>;
    /**
     * Start polling on the Task Queue for tasks. Completes after graceful {@link shutdown}, once the Worker reaches the
     * `'STOPPED'` state.
     *
     * Throws on a fatal error or failure to shutdown gracefully.
     *
     * @see {@link errors}
     *
     * To stop polling, call {@link shutdown} or send one of {@link Runtime.options.shutdownSignals}.
     */
    run(): Promise<void>;
}
export declare function parseWorkflowCode(code: string, codePath?: string): WorkflowBundleWithSourceMapAndFilename;
