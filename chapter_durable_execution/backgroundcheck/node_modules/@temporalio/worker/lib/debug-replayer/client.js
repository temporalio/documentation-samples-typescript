"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const node_http_1 = __importDefault(require("node:http"));
const pkg_1 = __importDefault(require("../pkg"));
/**
 * "High level" HTTP client, used to avoid adding more dependencies to the worker package.
 *
 * DO NOT use this in a real application, it's meant to only be used for calling a "runner" (e.g. VS Code debugger
 * extension).
 */
class Client {
    constructor(options) {
        this.options = options;
    }
    async post(url, options, body) {
        const request = node_http_1.default.request(`${this.options.baseUrl}/${url}`, {
            ...options,
            method: 'POST',
            headers: {
                'Temporal-Client-Name': 'temporal-typescript',
                'Temporal-Client-Version': pkg_1.default.version,
                'Content-Length': body.length,
                ...options?.headers,
            },
        });
        if (body) {
            await new Promise((resolve, reject) => {
                request.once('error', reject);
                request.write(body, (err) => {
                    request.off('error', reject);
                    if (err) {
                        reject();
                    }
                    else {
                        resolve();
                    }
                });
                request.end();
            });
        }
        const response = await new Promise((resolve, reject) => {
            request.once('error', reject);
            request.once('response', resolve);
        });
        if (response.statusCode !== 200) {
            let message = response.statusMessage;
            try {
                const responseBody = await Client.readAll(response);
                message = JSON.parse(responseBody.toString())?.error ?? message;
            }
            catch {
                // ignore
            }
            throw new Error(`Bad response code from VS Code: ${response.statusCode}: ${message}`);
        }
        return response;
    }
    async get(url, options) {
        const request = node_http_1.default.get(`${this.options.baseUrl}/${url}`, {
            ...options,
            headers: {
                'Temporal-Client-Name': 'temporal-typescript',
                'Temporal-Client-Version': pkg_1.default.version,
                ...options?.headers,
            },
        });
        const response = await new Promise((resolve, reject) => {
            request.once('error', reject);
            request.once('response', resolve);
        });
        if (response.statusCode !== 200) {
            let message = response.statusMessage;
            try {
                const responseBody = await Client.readAll(response);
                message = JSON.parse(responseBody.toString())?.error ?? message;
            }
            catch {
                // ignore
            }
            throw new Error(`Bad response code from VS Code: ${response.statusCode}: ${message}`);
        }
        return response;
    }
    static async readAll(response) {
        const chunks = Array();
        for await (const chunk of response) {
            chunks.push(chunk);
        }
        return Buffer.concat(chunks);
    }
    static contentLength(response) {
        const contentLength = response.headers['content-length'];
        if (!contentLength) {
            throw new Error('Empty response body when getting history');
        }
        return parseInt(contentLength);
    }
}
exports.Client = Client;
//# sourceMappingURL=client.js.map