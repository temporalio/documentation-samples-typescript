"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Activity = void 0;
require("abort-controller/polyfill"); // eslint-disable-line import/no-unassigned-import
const activity_1 = require("@temporalio/activity");
const common_1 = require("@temporalio/common");
const internal_non_workflow_1 = require("@temporalio/common/lib/internal-non-workflow");
const interceptors_1 = require("@temporalio/common/lib/interceptors");
const type_helpers_1 = require("@temporalio/common/lib/type-helpers");
const runtime_1 = require("./runtime");
class Activity {
    constructor(info, fn, dataConverter, heartbeatCallback, interceptors) {
        this.info = info;
        this.fn = fn;
        this.dataConverter = dataConverter;
        this.heartbeatCallback = heartbeatCallback;
        this.cancel = () => undefined;
        this.abortController = new AbortController();
        const promise = new Promise((_, reject) => {
            this.cancel = (reason) => {
                this.cancelReason = reason;
                this.abortController.abort();
                reject(new common_1.CancelledFailure(reason));
            };
        });
        this.context = new activity_1.Context(info, promise, this.abortController.signal, this.heartbeatCallback, runtime_1.Runtime.instance().logger);
        // Prevent unhandled rejection
        promise.catch(() => undefined);
        this.interceptors = {
            inbound: (interceptors?.inbound ?? []).map((factory) => factory(this.context)),
        };
    }
    /**
     * Actually executes the function.
     *
     * Exist mostly for cutting it out of the stack trace for failures.
     */
    async execute({ args }) {
        return await this.fn(...args);
    }
    run(input) {
        return activity_1.asyncLocalStorage.run(this.context, async () => {
            try {
                const execute = (0, interceptors_1.composeInterceptors)(this.interceptors.inbound, 'execute', (inp) => this.execute(inp));
                const result = await execute(input);
                return { completed: { result: await (0, internal_non_workflow_1.encodeToPayload)(this.dataConverter, result) } };
            }
            catch (err) {
                if (err instanceof activity_1.CompleteAsyncError) {
                    return { willCompleteAsync: {} };
                }
                if (this.cancelReason === 'HEARTBEAT_DETAILS_CONVERSION_FAILED') {
                    // Ignore actual failure, it is likely a CancelledFailure but server
                    // expects activity to only fail with ApplicationFailure
                    return {
                        failed: {
                            failure: await (0, internal_non_workflow_1.encodeErrorToFailure)(this.dataConverter, common_1.ApplicationFailure.retryable(this.cancelReason, 'CancelledFailure')),
                        },
                    };
                }
                else if (this.cancelReason) {
                    // Either a CancelledFailure that we threw or AbortError from AbortController
                    if (err instanceof common_1.CancelledFailure) {
                        const failure = await (0, internal_non_workflow_1.encodeErrorToFailure)(this.dataConverter, err);
                        failure.stackTrace = undefined;
                        return { cancelled: { failure } };
                    }
                    else if ((0, type_helpers_1.isAbortError)(err)) {
                        return { cancelled: { failure: { source: common_1.FAILURE_SOURCE, canceledFailureInfo: {} } } };
                    }
                }
                return {
                    failed: {
                        failure: await (0, internal_non_workflow_1.encodeErrorToFailure)(this.dataConverter, (0, common_1.ensureApplicationFailure)(err)),
                    },
                };
            }
        });
    }
}
exports.Activity = Activity;
//# sourceMappingURL=activity.js.map