"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseVMWorkflow = exports.globalHandlers = exports.GlobalHandlers = exports.injectConsole = exports.setUnhandledRejectionHandler = void 0;
const node_v8_1 = __importDefault(require("node:v8"));
const source_map_1 = require("source-map");
const common_1 = require("@temporalio/common");
const proto_1 = require("@temporalio/proto");
const internals = __importStar(require("@temporalio/workflow/lib/worker-interface"));
const utils_1 = require("../utils");
// Not present in @types/node for some reason
const { promiseHooks } = node_v8_1.default;
// Best effort to catch unhandled rejections from workflow code.
// We crash the thread if we cannot find the culprit.
function setUnhandledRejectionHandler(getWorkflowByRunId) {
    process.on('unhandledRejection', (err, promise) => {
        const activator = getActivator(promise);
        const runId = activator?.info?.runId;
        if (runId !== undefined) {
            const workflow = getWorkflowByRunId(runId);
            if (workflow !== undefined) {
                workflow.setUnhandledRejection(err);
                return;
            }
        }
        // The user's logger is not accessible in this thread,
        // dump the error information to stderr and abort.
        console.error('Unhandled rejection', { runId }, err);
        process.exit(1);
    });
}
exports.setUnhandledRejectionHandler = setUnhandledRejectionHandler;
/**
 * Variant of {@link cutoffStackTrace} that works with FileLocation, keep this in sync with the original implementation
 */
function cutoffStructuredStackTrace(stackTrace) {
    stackTrace.shift();
    if (stackTrace[0].functionName === 'initAll' && stackTrace[0].filePath === 'node:internal/promise_hooks') {
        stackTrace.shift();
    }
    const idx = stackTrace.findIndex(({ functionName, filePath }) => {
        return (functionName &&
            filePath &&
            ((/^Activator\.\S+NextHandler$/.test(functionName) &&
                /.*[\\/]workflow[\\/](?:src|lib)[\\/]internals\.[jt]s$/.test(filePath)) ||
                (/Script\.runInContext/.test(functionName) && /^node:vm|vm\.js$/.test(filePath))));
    });
    if (idx > -1) {
        stackTrace.splice(idx);
    }
}
function getActivator(promise) {
    // Access the global scope associated with the promise (unique per workflow - vm.context)
    // See for reference https://github.com/patriksimek/vm2/issues/32
    const ctor = promise.constructor.constructor;
    return ctor('return globalThis.__TEMPORAL_ACTIVATOR__')();
}
/**
 * Internal helper to format callsite "name" portion in stack trace
 */
function formatCallsiteName(callsite) {
    const typeName = callsite.getTypeName();
    const methodName = callsite.getMethodName();
    const functionName = callsite.getFunctionName();
    const isConstructor = callsite.isConstructor();
    return typeName && methodName
        ? `${typeName}.${methodName}`
        : isConstructor && functionName
            ? `new ${functionName}`
            : functionName;
}
/**
 * Inject console.log and friends into a vm context.
 */
function injectConsole(context) {
    const consoleMethods = ['log', 'warn', 'error', 'info', 'debug'];
    function makeConsoleFn(level) {
        return function (...args) {
            const { info } = context.__TEMPORAL_ACTIVATOR__;
            if (info.isReplaying)
                return;
            console[level](`[${info.workflowType}(${info.workflowId})]`, ...args);
        };
    }
    context.console = Object.fromEntries(consoleMethods.map((level) => [level, makeConsoleFn(level)]));
}
exports.injectConsole = injectConsole;
/**
 * Global handlers for overriding stack trace preparation and promise hooks
 */
class GlobalHandlers {
    constructor() {
        this.currentStackTrace = undefined;
        this.bundleFilenameToSourceMapConsumer = new Map();
        this.origPrepareStackTrace = Error.prepareStackTrace;
        this.stopPromiseHook = () => {
            // noop
        };
        this.installed = false;
    }
    async addWorkflowBundle(workflowBundle) {
        const sourceMapConsumer = await new source_map_1.SourceMapConsumer(workflowBundle.sourceMap);
        this.bundleFilenameToSourceMapConsumer.set(workflowBundle.filename, sourceMapConsumer);
    }
    removeWorkflowBundle(workflowBundle) {
        this.bundleFilenameToSourceMapConsumer.delete(workflowBundle.filename);
    }
    /**
     * Set the global hooks, this method is idempotent
     */
    install() {
        if (!this.installed) {
            this.overridePrepareStackTrace();
            this.setPromiseHook();
            this.installed = true;
        }
    }
    /**
     * Unset all installed global hooks
     *
     * This method is not called anywhere since we typically install the hooks in a separate thread which is cleaned up
     * after worker shutdown. Is debug mode we don't clean these up but that should be insignificant.
     */
    uninstall() {
        this.stopPromiseHook();
        Error.prepareStackTrace = this.origPrepareStackTrace;
        this.installed = false;
    }
    overridePrepareStackTrace() {
        const OuterError = Error;
        // Augment the vm-global Error stack trace prepare function
        // NOTE: this means that multiple instances of this class in the same VM
        // will override each other.
        // This should be a non-issue in most cases since we typically construct a single instance of
        // this class per Worker thread.
        // See: https://v8.dev/docs/stack-trace-api#customizing-stack-traces
        Error.prepareStackTrace = (err, stackTraces) => {
            const inWorkflowContext = OuterError !== err.constructor;
            if (this.origPrepareStackTrace && !inWorkflowContext) {
                return this.origPrepareStackTrace(err, stackTraces);
            }
            // Set the currentStackTrace so it can be used in the promise `init` hook below
            this.currentStackTrace = [];
            const converted = stackTraces.map((callsite) => {
                const line = callsite.getLineNumber();
                const column = callsite.getColumnNumber();
                const filename = callsite.getFileName();
                const sourceMapConsumer = filename && this.bundleFilenameToSourceMapConsumer.get(filename);
                if (sourceMapConsumer && line && column) {
                    const pos = sourceMapConsumer.originalPositionFor({ line, column });
                    const name = pos.name || formatCallsiteName(callsite);
                    this.currentStackTrace?.push({
                        filePath: pos.source ?? undefined,
                        functionName: name ?? undefined,
                        line: pos.line ?? undefined,
                        column: pos.column ?? undefined,
                    });
                    return name
                        ? `    at ${name} (${pos.source}:${pos.line}:${pos.column})`
                        : `    at ${pos.source}:${pos.line}:${pos.column}`;
                }
                else {
                    const name = formatCallsiteName(callsite);
                    this.currentStackTrace?.push({
                        filePath: filename ?? undefined,
                        functionName: name ?? undefined,
                        line: line ?? undefined,
                        column: column ?? undefined,
                    });
                    return `    at ${callsite}`;
                }
            });
            return `${err}\n${converted.join('\n')}`;
        };
    }
    setPromiseHook() {
        // Track Promise aggregators like `race` and `all` to link their internally created promises
        let currentAggregation = undefined;
        // This also is set globally for the isolate (worker thread), which is insignificant unless the worker is run in debug mode
        if (promiseHooks) {
            // Node >=16.14 only
            this.stopPromiseHook = promiseHooks.createHook({
                init: (promise, parent) => {
                    // Only run in workflow context
                    const activator = getActivator(promise);
                    if (!activator)
                        return;
                    const store = activator.promiseStackStore;
                    // TODO: hide this somehow: defineProperty + symbol
                    promise.runId = activator.info.runId;
                    // Reset currentStackTrace just in case (it will be set in `prepareStackTrace` above)
                    this.currentStackTrace = undefined;
                    const fn = promise.constructor.constructor;
                    const ErrorCtor = fn('return globalThis.Error')();
                    // To see the full stack replace with commented line
                    // const formatted = new ErrorCtor().stack?.replace(/^Error\n\s*at [^\n]+\n(\s*at initAll \(node:internal\/promise_hooks:\d+:\d+\)\n)?/, '')!;
                    const formatted = (0, common_1.cutoffStackTrace)(new ErrorCtor().stack?.replace(/^Error\n\s*at [^\n]+\n(\s*at initAll \(node:internal\/promise_hooks:\d+:\d+\)\n)?/, ''));
                    if (this.currentStackTrace === undefined) {
                        return;
                    }
                    const structured = this.currentStackTrace;
                    cutoffStructuredStackTrace(structured);
                    let stackTrace = { formatted, structured };
                    if (currentAggregation &&
                        /^\s+at\sPromise\.then \(<anonymous>\)\n\s+at Function\.(race|all|allSettled|any) \(<anonymous>\)\n/.test(formatted)) {
                        // Skip internal promises created by the aggregator and link directly.
                        promise = currentAggregation;
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        stackTrace = store.promiseToStack.get(currentAggregation); // Must exist
                    }
                    else if (/^\s+at Function\.(race|all|allSettled|any) \(<anonymous>\)\n/.test(formatted)) {
                        currentAggregation = promise;
                    }
                    else {
                        currentAggregation = undefined;
                    }
                    // This is weird but apparently it happens
                    if (promise === parent) {
                        return;
                    }
                    store.promiseToStack.set(promise, stackTrace);
                    // In case of Promise.race and friends we might have multiple "parents"
                    const parents = store.childToParent.get(promise) ?? new Set();
                    if (parent) {
                        parents.add(parent);
                    }
                    store.childToParent.set(promise, parents);
                },
                settled(promise) {
                    // Only run in workflow context
                    const store = getActivator(promise)?.promiseStackStore;
                    if (!store)
                        return;
                    store.childToParent.delete(promise);
                    store.promiseToStack.delete(promise);
                },
            });
        }
    }
}
exports.GlobalHandlers = GlobalHandlers;
exports.globalHandlers = new GlobalHandlers();
/**
 * A Workflow implementation using Node.js' built-in `vm` module
 */
class BaseVMWorkflow {
    constructor(info, context, activator, workflowModule, isolateExecutionTimeoutMs) {
        this.info = info;
        this.context = context;
        this.activator = activator;
        this.workflowModule = workflowModule;
        this.isolateExecutionTimeoutMs = isolateExecutionTimeoutMs;
    }
    /**
     * Send request to the Workflow runtime's worker-interface
     */
    async getAndResetSinkCalls() {
        return this.workflowModule.getAndResetSinkCalls();
    }
    /**
     * Send request to the Workflow runtime's worker-interface
     *
     * The Workflow is activated in batches to ensure correct order of activation
     * job application.
     */
    async activate(activation) {
        if (this.context === undefined) {
            throw new common_1.IllegalStateError('Workflow isolate context uninitialized');
        }
        if (!activation.jobs) {
            throw new Error('Expected workflow activation jobs to be defined');
        }
        // Job processing order
        // 1. patch notifications
        // 2. signals
        // 3. anything left except for queries
        // 4. queries
        const [patches, nonPatches] = (0, utils_1.partition)(activation.jobs, ({ notifyHasPatch }) => notifyHasPatch != null);
        const [signals, nonSignals] = (0, utils_1.partition)(nonPatches, ({ signalWorkflow }) => signalWorkflow != null);
        const [queries, rest] = (0, utils_1.partition)(nonSignals, ({ queryWorkflow }) => queryWorkflow != null);
        let batchIndex = 0;
        // Loop and invoke each batch and wait for microtasks to complete.
        // This is done outside of the isolate because when we used isolated-vm we couldn't wait for microtasks from inside the isolate, not relevant anymore.
        for (const jobs of [patches, signals, rest, queries]) {
            if (jobs.length === 0) {
                continue;
            }
            this.workflowModule.activate(proto_1.coresdk.workflow_activation.WorkflowActivation.fromObject({ ...activation, jobs }), batchIndex++);
            if (internals.shouldUnblockConditions(jobs[0])) {
                this.tryUnblockConditions();
            }
        }
        const completion = this.workflowModule.concludeActivation();
        // Give unhandledRejection handler a chance to be triggered.
        await new Promise(setImmediate);
        if (this.unhandledRejection) {
            return {
                runId: this.activator.info.runId,
                failed: { failure: this.activator.errorToFailure(this.unhandledRejection) },
            };
        }
        return completion;
    }
    /**
     * If called (by an external unhandledRejection handler), activations will fail with provided error.
     */
    setUnhandledRejection(err) {
        this.unhandledRejection = err;
    }
    /**
     * Call into the Workflow context to attempt to unblock any blocked conditions.
     *
     * This is performed in a loop allowing microtasks to be processed between
     * each iteration until there are no more conditions to unblock.
     */
    tryUnblockConditions() {
        for (;;) {
            const numUnblocked = this.workflowModule.tryUnblockConditions();
            if (numUnblocked === 0)
                break;
        }
    }
}
exports.BaseVMWorkflow = BaseVMWorkflow;
//# sourceMappingURL=vm-shared.js.map