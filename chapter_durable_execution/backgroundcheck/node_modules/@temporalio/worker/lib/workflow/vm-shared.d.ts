/// <reference types="node" />
/// <reference types="node" />
import vm from 'node:vm';
import { SourceMapConsumer } from 'source-map';
import { coresdk } from '@temporalio/proto';
import type { WorkflowInfo, FileLocation } from '@temporalio/workflow';
import { SinkCall } from '@temporalio/workflow/lib/sinks';
import * as internals from '@temporalio/workflow/lib/worker-interface';
import { Activator } from '@temporalio/workflow/lib/internals';
import { Workflow } from './interface';
import { WorkflowBundleWithSourceMapAndFilename } from './workflow-worker-thread/input';
export declare function setUnhandledRejectionHandler(getWorkflowByRunId: (runId: string) => BaseVMWorkflow | undefined): void;
/**
 * Inject console.log and friends into a vm context.
 */
export declare function injectConsole(context: vm.Context): void;
/**
 * Global handlers for overriding stack trace preparation and promise hooks
 */
export declare class GlobalHandlers {
    currentStackTrace: FileLocation[] | undefined;
    bundleFilenameToSourceMapConsumer: Map<string, SourceMapConsumer>;
    origPrepareStackTrace: ((err: Error, stackTraces: NodeJS.CallSite[]) => any) | undefined;
    private stopPromiseHook;
    installed: boolean;
    addWorkflowBundle(workflowBundle: WorkflowBundleWithSourceMapAndFilename): Promise<void>;
    removeWorkflowBundle(workflowBundle: WorkflowBundleWithSourceMapAndFilename): void;
    /**
     * Set the global hooks, this method is idempotent
     */
    install(): void;
    /**
     * Unset all installed global hooks
     *
     * This method is not called anywhere since we typically install the hooks in a separate thread which is cleaned up
     * after worker shutdown. Is debug mode we don't clean these up but that should be insignificant.
     */
    uninstall(): void;
    private overridePrepareStackTrace;
    private setPromiseHook;
}
export declare const globalHandlers: GlobalHandlers;
export type WorkflowModule = typeof internals;
/**
 * A Workflow implementation using Node.js' built-in `vm` module
 */
export declare abstract class BaseVMWorkflow implements Workflow {
    readonly info: WorkflowInfo;
    protected context: vm.Context | undefined;
    protected activator: Activator;
    readonly workflowModule: WorkflowModule;
    readonly isolateExecutionTimeoutMs: number;
    unhandledRejection: unknown;
    constructor(info: WorkflowInfo, context: vm.Context | undefined, activator: Activator, workflowModule: WorkflowModule, isolateExecutionTimeoutMs: number);
    /**
     * Send request to the Workflow runtime's worker-interface
     */
    getAndResetSinkCalls(): Promise<SinkCall[]>;
    /**
     * Send request to the Workflow runtime's worker-interface
     *
     * The Workflow is activated in batches to ensure correct order of activation
     * job application.
     */
    activate(activation: coresdk.workflow_activation.IWorkflowActivation): Promise<coresdk.workflow_completion.IWorkflowActivationCompletion>;
    /**
     * If called (by an external unhandledRejection handler), activations will fail with provided error.
     */
    setUnhandledRejection(err: unknown): void;
    /**
     * Call into the Workflow context to attempt to unblock any blocked conditions.
     *
     * This is performed in a loop allowing microtasks to be processed between
     * each iteration until there are no more conditions to unblock.
     */
    protected tryUnblockConditions(): void;
    /**
     * Do not use this Workflow instance after this method has been called.
     */
    abstract dispose(): Promise<void>;
}
