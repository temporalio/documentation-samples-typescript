"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseWorkflowCode = exports.Worker = exports.NativeWorker = exports.CombinedWorkerRunError = exports.defaultPayloadConverter = void 0;
const node_crypto_1 = __importDefault(require("node:crypto"));
const promises_1 = __importDefault(require("node:fs/promises"));
const path = __importStar(require("node:path"));
const vm = __importStar(require("node:vm"));
const node_util_1 = require("node:util");
const node_events_1 = require("node:events");
const otel = __importStar(require("@opentelemetry/api"));
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const common_1 = require("@temporalio/common");
Object.defineProperty(exports, "defaultPayloadConverter", { enumerable: true, get: function () { return common_1.defaultPayloadConverter; } });
const internal_non_workflow_1 = require("@temporalio/common/lib/internal-non-workflow");
const otel_1 = require("@temporalio/common/lib/otel");
const proto_utils_1 = require("@temporalio/common/lib/proto-utils");
const time_1 = require("@temporalio/common/lib/time");
const type_helpers_1 = require("@temporalio/common/lib/type-helpers");
const native = __importStar(require("@temporalio/core-bridge"));
const core_bridge_1 = require("@temporalio/core-bridge");
const proto_1 = require("@temporalio/proto");
const activity_1 = require("./activity");
const activity_log_interceptor_1 = require("./activity-log-interceptor");
const connection_1 = require("./connection");
const pkg_1 = __importDefault(require("./pkg"));
const replay_1 = require("./replay");
const runtime_1 = require("./runtime");
const rxutils_1 = require("./rxutils");
const tracing_1 = require("./tracing");
const utils_1 = require("./utils");
const worker_options_1 = require("./worker-options");
const workflow_codec_runner_1 = require("./workflow-codec-runner");
const workflow_log_interceptor_1 = require("./workflow-log-interceptor");
const bundler_1 = require("./workflow/bundler");
const reusable_vm_1 = require("./workflow/reusable-vm");
const threaded_vm_1 = require("./workflow/threaded-vm");
const vm_1 = require("./workflow/vm");
const errors_1 = require("./errors");
/**
 * Error thrown by {@link Worker.runUntil} and {@link Worker.runReplayHistories}
 */
let CombinedWorkerRunError = class CombinedWorkerRunError extends Error {
    constructor(message, { cause }) {
        super(message);
        this.cause = cause;
    }
};
CombinedWorkerRunError = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('CombinedWorkerRunError')
], CombinedWorkerRunError);
exports.CombinedWorkerRunError = CombinedWorkerRunError;
function isOptionsWithBuildId(options) {
    return options.buildId != null;
}
function addBuildIdIfMissing(options, bundleCode) {
    if (isOptionsWithBuildId(options)) {
        return options;
    }
    const suffix = bundleCode ? `+${node_crypto_1.default.createHash('sha256').update(bundleCode).digest('hex')}` : '';
    return { ...options, buildId: `${pkg_1.default.name}@${pkg_1.default.version}${suffix}` };
}
class NativeWorker {
    static async create(connection, options) {
        const runtime = runtime_1.Runtime.instance();
        const nativeWorker = await runtime.registerWorker((0, connection_1.extractNativeClient)(connection), options);
        return new NativeWorker(runtime, nativeWorker);
    }
    static async createReplay(options) {
        const runtime = runtime_1.Runtime.instance();
        const replayer = await runtime.createReplayWorker(options);
        return { worker: new NativeWorker(runtime, replayer.worker), historyPusher: replayer.pusher };
    }
    constructor(runtime, nativeWorker) {
        this.runtime = runtime;
        this.nativeWorker = nativeWorker;
        this.type = 'Worker';
        this.pollWorkflowActivation = (0, node_util_1.promisify)(native.workerPollWorkflowActivation).bind(undefined, nativeWorker);
        this.pollActivityTask = (0, node_util_1.promisify)(native.workerPollActivityTask).bind(undefined, nativeWorker);
        this.completeWorkflowActivation = (0, node_util_1.promisify)(native.workerCompleteWorkflowActivation).bind(undefined, nativeWorker);
        this.completeActivityTask = (0, node_util_1.promisify)(native.workerCompleteActivityTask).bind(undefined, nativeWorker);
        this.recordActivityHeartbeat = native.workerRecordActivityHeartbeat.bind(undefined, nativeWorker);
        this.initiateShutdown = (0, node_util_1.promisify)(native.workerInitiateShutdown).bind(undefined, nativeWorker);
    }
    flushCoreLogs() {
        this.runtime.flushLogs();
    }
    async finalizeShutdown() {
        await this.runtime.deregisterWorker(this.nativeWorker);
    }
    get logger() {
        return this.runtime.logger;
    }
}
exports.NativeWorker = NativeWorker;
function formatTaskToken(taskToken) {
    return Buffer.from(taskToken).toString('base64');
}
/**
 * The temporal Worker connects to Temporal Server and runs Workflows and Activities.
 */
class Worker {
    /**
     * Create a new Worker.
     * This method initiates a connection to the server and will throw (asynchronously) on connection failure.
     */
    static async create(options) {
        const nativeWorkerCtor = this.nativeWorkerCtor;
        const compiledOptions = (0, worker_options_1.compileWorkerOptions)((0, worker_options_1.addDefaultWorkerOptions)(options));
        runtime_1.Runtime.instance().logger.info('Creating worker', {
            options: {
                ...compiledOptions,
                ...(compiledOptions.workflowBundle && (0, worker_options_1.isCodeBundleOption)(compiledOptions.workflowBundle)
                    ? {
                        // Avoid dumping workflow bundle code to the console
                        workflowBundle: {
                            code: `<string of length ${compiledOptions.workflowBundle.code.length}>`,
                        },
                    }
                    : {}),
            },
        });
        const bundle = await this.getOrCreateBundle(compiledOptions, runtime_1.Runtime.instance().logger);
        let workflowCreator = undefined;
        if (bundle) {
            workflowCreator = await this.createWorkflowCreator(bundle, compiledOptions);
        }
        // Create a new connection if one is not provided with no CREATOR reference
        // so it can be automatically closed when this Worker shuts down.
        const connection = options.connection ?? (await connection_1.InternalNativeConnection.connect());
        let nativeWorker;
        const compiledOptionsWithBuildId = addBuildIdIfMissing(compiledOptions, bundle?.code);
        try {
            nativeWorker = await nativeWorkerCtor.create(connection, compiledOptionsWithBuildId);
        }
        catch (err) {
            // We just created this connection, close it
            if (!options.connection) {
                await connection.close();
            }
            throw err;
        }
        (0, connection_1.extractReferenceHolders)(connection).add(nativeWorker);
        return new this(nativeWorker, workflowCreator, compiledOptionsWithBuildId, connection);
    }
    static async createWorkflowCreator(workflowBundle, compiledOptions) {
        const registeredActivityNames = new Set(Object.entries(compiledOptions.activities ?? {})
            .filter(([_, v]) => typeof v === 'function')
            .map(([k]) => k));
        // This isn't required for vscode, only for Chrome Dev Tools which doesn't support debugging worker threads.
        // We also rely on this in debug-replayer where we inject a global variable to be read from workflow context.
        if (compiledOptions.debugMode) {
            if (compiledOptions.reuseV8Context) {
                return await reusable_vm_1.ReusableVMWorkflowCreator.create(workflowBundle, compiledOptions.isolateExecutionTimeoutMs, registeredActivityNames);
            }
            return await vm_1.VMWorkflowCreator.create(workflowBundle, compiledOptions.isolateExecutionTimeoutMs, registeredActivityNames);
        }
        else {
            return await threaded_vm_1.ThreadedVMWorkflowCreator.create({
                workflowBundle,
                threadPoolSize: compiledOptions.workflowThreadPoolSize,
                isolateExecutionTimeoutMs: compiledOptions.isolateExecutionTimeoutMs,
                reuseV8Context: compiledOptions.reuseV8Context ?? false,
                registeredActivityNames,
            });
        }
    }
    /**
     * Create a replay Worker, and run the provided history against it. Will resolve as soon as
     * the history has finished being replayed, or if the workflow produces a nondeterminism error.
     *
     * @param workflowId If provided, use this as the workflow id during replay. Histories do not
     * contain a workflow id, so it must be provided separately if your workflow depends on it.
     * @throws {@link DeterminismViolationError} if the workflow code is not compatible with the history.
     * @throws {@link ReplayError} on any other replay related error.
     */
    static async runReplayHistory(options, history, workflowId) {
        const validated = this.validateHistory(history);
        const result = await this.runReplayHistories(options, [
            { history: validated, workflowId: workflowId ?? 'fake' },
        ]).next();
        if (result.done)
            throw new common_1.IllegalStateError('Expected at least one replay result');
        if (result.value.error)
            throw result.value.error;
    }
    /**
     * Create a replay Worker, running all histories provided by the passed in iterable.
     *
     * Returns an async iterable of results for each history replayed.
     */
    static async *runReplayHistories(options, histories) {
        const [worker, pusher] = await this.constructReplayWorker(options);
        const rt = runtime_1.Runtime.instance();
        const evictions = (0, node_events_1.on)(worker.evictionsEmitter, 'eviction');
        const runPromise = worker.run().then(() => {
            throw new core_bridge_1.ShutdownError('Worker was shutdown');
        });
        void runPromise.catch(() => {
            // ignore to avoid unhandled rejections
        });
        let innerError = undefined;
        try {
            try {
                for await (const { history, workflowId } of histories) {
                    const validated = this.validateHistory(history);
                    await rt.pushHistory(pusher, workflowId, validated);
                    const next = await Promise.race([evictions.next(), runPromise]);
                    if (next.done) {
                        break; // This shouldn't happen, handle just in case
                    }
                    const [{ runId, evictJob }] = next.value;
                    const error = (0, replay_1.evictionReasonToReplayError)(evictJob);
                    // We replay one workflow at a time so the workflow ID comes from the histories iterable.
                    yield {
                        workflowId,
                        runId,
                        error,
                    };
                }
            }
            catch (err) {
                innerError = err;
            }
        }
        finally {
            try {
                rt.closeHistoryStream(pusher);
                worker.shutdown();
            }
            catch {
                // ignore in case worker was already shutdown
            }
            try {
                await runPromise;
            }
            catch (err) {
                /* eslint-disable no-unsafe-finally */
                if (err instanceof core_bridge_1.ShutdownError) {
                    if (innerError !== undefined)
                        throw innerError;
                    return;
                }
                else if (innerError === undefined) {
                    throw err;
                }
                else {
                    throw new CombinedWorkerRunError('Worker run failed with inner error', {
                        cause: {
                            workerError: err,
                            innerError,
                        },
                    });
                }
                /* eslint-enable no-unsafe-finally */
            }
        }
    }
    static validateHistory(history) {
        if (typeof history !== 'object' || history == null) {
            throw new TypeError(`Expected a non-null history object, got ${typeof history}`);
        }
        const { eventId } = history.events[0];
        // in a "valid" history, eventId would be Long
        if (typeof eventId === 'string') {
            return (0, proto_utils_1.historyFromJSON)(history);
        }
        else {
            return history;
        }
    }
    static async constructReplayWorker(options) {
        const nativeWorkerCtor = this.nativeWorkerCtor;
        const fixedUpOptions = {
            taskQueue: (options.replayName ?? 'fake_replay_queue') + '-' + this.replayWorkerCount,
            debugMode: true,
            ...options,
        };
        this.replayWorkerCount++;
        const compiledOptions = (0, worker_options_1.compileWorkerOptions)((0, worker_options_1.addDefaultWorkerOptions)(fixedUpOptions));
        const bundle = await this.getOrCreateBundle(compiledOptions, runtime_1.Runtime.instance().logger);
        if (!bundle) {
            throw new TypeError('ReplayWorkerOptions must contain workflowsPath or workflowBundle');
        }
        const workflowCreator = await this.createWorkflowCreator(bundle, compiledOptions);
        const replayHandle = await nativeWorkerCtor.createReplay(addBuildIdIfMissing(compiledOptions, bundle.code));
        return [
            new this(replayHandle.worker, workflowCreator, compiledOptions, undefined, true),
            replayHandle.historyPusher,
        ];
    }
    static async getOrCreateBundle(compiledOptions, logger) {
        if (compiledOptions.workflowBundle) {
            if (compiledOptions.workflowsPath) {
                logger.warn('Ignoring WorkerOptions.workflowsPath because WorkerOptions.workflowBundle is set');
            }
            if (compiledOptions.bundlerOptions) {
                logger.warn('Ignoring WorkerOptions.bundlerOptions because WorkerOptions.workflowBundle is set');
            }
            const modules = compiledOptions.interceptors?.workflowModules;
            // Warn if user tries to customize the default set of workflow interceptor modules
            if (modules && new Set([...modules, ...bundler_1.defaultWorkflowInterceptorModules]).size !== modules.length) {
                logger.warn('Ignoring WorkerOptions.interceptors.workflowModules because WorkerOptions.workflowBundle is set.\n' +
                    'To use workflow interceptors with a workflowBundle, pass them in the call to bundleWorkflowCode.');
            }
            if ((0, worker_options_1.isCodeBundleOption)(compiledOptions.workflowBundle)) {
                return parseWorkflowCode(compiledOptions.workflowBundle.code);
            }
            else if ((0, worker_options_1.isPathBundleOption)(compiledOptions.workflowBundle)) {
                const code = await promises_1.default.readFile(compiledOptions.workflowBundle.codePath, 'utf8');
                return parseWorkflowCode(code, compiledOptions.workflowBundle.codePath);
            }
            else {
                throw new TypeError('Invalid WorkflowOptions.workflowBundle');
            }
        }
        else if (compiledOptions.workflowsPath) {
            const bundler = new bundler_1.WorkflowCodeBundler({
                logger,
                workflowsPath: compiledOptions.workflowsPath,
                workflowInterceptorModules: compiledOptions.interceptors?.workflowModules,
                failureConverterPath: compiledOptions.dataConverter?.failureConverterPath,
                payloadConverterPath: compiledOptions.dataConverter?.payloadConverterPath,
                ignoreModules: compiledOptions.bundlerOptions?.ignoreModules,
                webpackConfigHook: compiledOptions.bundlerOptions?.webpackConfigHook,
            });
            const bundle = await bundler.createBundle();
            return parseWorkflowCode(bundle.code);
        }
        else {
            return undefined;
        }
    }
    /**
     * Create a new Worker from nativeWorker.
     */
    constructor(nativeWorker, 
    /**
     * Optional WorkflowCreator - if not provided, Worker will not poll on Workflows
     */
    workflowCreator, options, connection, isReplayWorker = false) {
        this.nativeWorker = nativeWorker;
        this.workflowCreator = workflowCreator;
        this.options = options;
        this.connection = connection;
        this.isReplayWorker = isReplayWorker;
        this.activityHeartbeatSubject = new rxjs_1.Subject();
        this.unexpectedErrorSubject = new rxjs_1.Subject();
        this.stateSubject = new rxjs_1.BehaviorSubject('INITIALIZED');
        this.workflowPollerStateSubject = new rxjs_1.BehaviorSubject('POLLING');
        this.activityPollerStateSubject = new rxjs_1.BehaviorSubject('POLLING');
        /**
         * Whether or not this worker has an outstanding workflow poll request
         */
        this.hasOutstandingWorkflowPoll = false;
        /**
         * Whether or not this worker has an outstanding activity poll request
         */
        this.hasOutstandingActivityPoll = false;
        this.numInFlightActivationsSubject = new rxjs_1.BehaviorSubject(0);
        this.numInFlightActivitiesSubject = new rxjs_1.BehaviorSubject(0);
        this.numCachedWorkflowsSubject = new rxjs_1.BehaviorSubject(0);
        this.numHeartbeatingActivitiesSubject = new rxjs_1.BehaviorSubject(0);
        this.evictionsEmitter = new node_events_1.EventEmitter();
        this.runIdsToSpanContext = new Map();
        this.tracer = (0, tracing_1.getTracer)(options.enableSDKTracing);
        this.workflowCodecRunner = new workflow_codec_runner_1.WorkflowCodecRunner(options.loadedDataConverter.payloadCodecs);
    }
    /**
     * An Observable which emits each time the number of in flight activations changes
     */
    get numInFlightActivations$() {
        return this.numInFlightActivationsSubject;
    }
    /**
     * An Observable which emits each time the number of in flight Activity tasks changes
     */
    get numInFlightActivities$() {
        return this.numInFlightActivitiesSubject;
    }
    /**
     * An Observable which emits each time the number of cached workflows changes
     */
    get numRunningWorkflowInstances$() {
        return this.numCachedWorkflowsSubject;
    }
    get log() {
        return this.nativeWorker.logger;
    }
    /**
     * Get the poll state of this worker
     */
    getState() {
        // Setters and getters require the same visibility, add this public getter function
        return this.stateSubject.getValue();
    }
    /**
     * Get a status overview of this Worker
     */
    getStatus() {
        return {
            runState: this.state,
            numHeartbeatingActivities: this.numHeartbeatingActivitiesSubject.value,
            workflowPollerState: this.workflowPollerStateSubject.value,
            activityPollerState: this.activityPollerStateSubject.value,
            hasOutstandingWorkflowPoll: this.hasOutstandingWorkflowPoll,
            hasOutstandingActivityPoll: this.hasOutstandingActivityPoll,
            numCachedWorkflows: this.numCachedWorkflowsSubject.value,
            numInFlightWorkflowActivations: this.numInFlightActivationsSubject.value,
            numInFlightActivities: this.numInFlightActivitiesSubject.value,
        };
    }
    get state() {
        return this.stateSubject.getValue();
    }
    set state(state) {
        this.log.info('Worker state changed', { state });
        this.stateSubject.next(state);
    }
    /**
     * Start shutting down the Worker. The Worker stops polling for new tasks and sends
     * {@link https://typescript.temporal.io/api/namespaces/activity#cancellation | cancellation} (via a
     * {@link CancelledFailure} with `message` set to `'WORKER_SHUTDOWN'`) to running Activities. Note: if the Activity
     * accepts cancellation (i.e. re-throws or allows the `CancelledFailure` to be thrown out of the Activity function),
     * the Activity Task will be marked as failed, not cancelled. It's helpful for the Activity Task to be marked failed
     * during shutdown because the Server will retry the Activity sooner (than if the Server had to wait for the Activity
     * Task to time out).
     *
     * When called, immediately transitions {@link state} to `'STOPPING'` and asks Core to shut down. Once Core has
     * confirmed that it's shutting down, the Worker enters `'DRAINING'` state unless the Worker has already been
     * `'DRAINED'`. Once all currently running Activities and Workflow Tasks have completed, the Worker transitions to
     * `'STOPPED'`.
     */
    shutdown() {
        if (this.state !== 'RUNNING') {
            throw new common_1.IllegalStateError('Not running');
        }
        this.state = 'STOPPING';
        this.nativeWorker
            .initiateShutdown()
            .then(() => {
            // Core may have already returned a ShutdownError to our pollers in which
            // case the state would transition to DRAINED
            if (this.state === 'STOPPING') {
                this.state = 'DRAINING';
            }
        })
            .catch((error) => this.unexpectedErrorSubject.error(error));
    }
    /**
     * An observable that completes when {@link state} becomes `'DRAINED'` or throws if {@link state} transitions to
     * `'STOPPING'` and remains that way for {@link this.options.shutdownForceTimeMs}.
     */
    forceShutdown$() {
        if (this.options.shutdownForceTimeMs == null) {
            return rxjs_1.EMPTY;
        }
        return (0, rxjs_1.race)(this.stateSubject.pipe((0, operators_1.filter)((state) => state === 'STOPPING'), (0, operators_1.delay)(this.options.shutdownForceTimeMs), (0, operators_1.map)(() => {
            throw new errors_1.GracefulShutdownPeriodExpiredError('Timed out while waiting for worker to shutdown gracefully');
        })), this.stateSubject.pipe((0, operators_1.filter)((state) => state === 'DRAINED'), (0, operators_1.first)())).pipe((0, operators_1.ignoreElements)());
    }
    /**
     * An observable which repeatedly polls for new tasks unless worker becomes suspended.
     * The observable stops emitting once core is shutting down.
     */
    pollLoop$(pollFn) {
        return (0, rxjs_1.from)((async function* () {
            for (;;) {
                try {
                    yield await pollFn();
                }
                catch (err) {
                    if (err instanceof core_bridge_1.ShutdownError) {
                        break;
                    }
                    throw err;
                }
            }
        })());
    }
    /**
     * Process Activity tasks
     */
    activityOperator() {
        return (0, rxjs_1.pipe)((0, rxutils_1.closeableGroupBy)(({ base64TaskToken }) => base64TaskToken), (0, operators_1.mergeMap)((group$) => {
            return group$.pipe((0, rxutils_1.mergeMapWithState)(async (activity, { task, parentSpan, base64TaskToken }) => {
                const { taskToken, variant } = task;
                if (!variant) {
                    throw new TypeError('Got an activity task without a "variant" attribute');
                }
                return await (0, tracing_1.instrument)(this.tracer, parentSpan, `activity.${variant}`, async (span) => {
                    // We either want to return an activity result (for failures) or pass on the activity for running at a later stage
                    // If cancel is requested we ignore the result of this function
                    // We don't run the activity directly in this operator because we need to return the activity in the state
                    // so it can be cancelled if requested
                    let output;
                    switch (variant) {
                        case 'start': {
                            if (activity !== undefined) {
                                throw new common_1.IllegalStateError(`Got start event for an already running activity: ${base64TaskToken}`);
                            }
                            const info = await extractActivityInfo(task, this.options.loadedDataConverter, this.options.namespace, this.options.taskQueue);
                            const { activityType } = info;
                            // activities is of type "object" which does not support string indexes
                            const fn = this.options.activities?.[activityType];
                            if (typeof fn !== 'function') {
                                output = {
                                    type: 'result',
                                    result: {
                                        failed: {
                                            failure: {
                                                message: `Activity function ${activityType} is not registered on this Worker, available activities: ${JSON.stringify(Object.keys(this.options.activities ?? {}))}`,
                                                applicationFailureInfo: { type: 'NotFoundError', nonRetryable: false },
                                            },
                                        },
                                    },
                                    parentSpan,
                                };
                                break;
                            }
                            let args;
                            try {
                                args = await (0, internal_non_workflow_1.decodeArrayFromPayloads)(this.options.loadedDataConverter, task.start?.input);
                            }
                            catch (err) {
                                output = {
                                    type: 'result',
                                    result: {
                                        failed: {
                                            failure: {
                                                message: `Failed to parse activity args for activity ${activityType}: ${(0, type_helpers_1.errorMessage)(err)}`,
                                                applicationFailureInfo: {
                                                    type: (0, type_helpers_1.isError)(err) ? err.name : undefined,
                                                    nonRetryable: false,
                                                },
                                            },
                                        },
                                    },
                                    parentSpan,
                                };
                                break;
                            }
                            const headers = task.start?.headerFields ?? {};
                            const input = {
                                args,
                                headers,
                            };
                            this.log.trace('Starting activity', (0, activity_log_interceptor_1.activityLogAttributes)(info));
                            activity = new activity_1.Activity(info, fn, this.options.loadedDataConverter, (details) => this.activityHeartbeatSubject.next({
                                type: 'heartbeat',
                                info,
                                taskToken,
                                base64TaskToken,
                                details,
                                onError() {
                                    activity?.cancel('HEARTBEAT_DETAILS_CONVERSION_FAILED'); // activity must be defined
                                },
                            }), { inbound: this.options.interceptors?.activityInbound });
                            output = { type: 'run', activity, input, parentSpan };
                            break;
                        }
                        case 'cancel': {
                            output = { type: 'ignore', parentSpan };
                            if (activity === undefined) {
                                this.log.error('Tried to cancel a non-existing activity', { taskToken: base64TaskToken });
                                span.setAttribute('found', false);
                                break;
                            }
                            // NOTE: activity will not be considered cancelled until it confirms cancellation (by throwing a CancelledFailure)
                            this.log.trace('Cancelling activity', (0, activity_log_interceptor_1.activityLogAttributes)(activity.info));
                            span.setAttribute('found', true);
                            const reason = task.cancel?.reason;
                            if (reason === undefined || reason === null) {
                                // Special case of Lang side cancellation during shutdown (see `activity.shutdown.evict` above)
                                activity.cancel('WORKER_SHUTDOWN');
                            }
                            else {
                                activity.cancel(proto_1.coresdk.activity_task.ActivityCancelReason[reason]);
                            }
                            break;
                        }
                    }
                    return { state: activity, output: { taskToken, output } };
                });
            }, undefined // initial value
            ), (0, operators_1.mergeMap)(async ({ output, taskToken }) => {
                if (output.type === 'ignore') {
                    output.parentSpan.end();
                    return undefined;
                }
                if (output.type === 'result') {
                    return { taskToken, result: output.result, parentSpan: output.parentSpan };
                }
                const { base64TaskToken } = output.activity.info;
                this.activityHeartbeatSubject.next({
                    type: 'create',
                    base64TaskToken,
                });
                return await (0, tracing_1.instrument)(this.tracer, output.parentSpan, 'activity.run', async (span) => {
                    let result;
                    this.numInFlightActivitiesSubject.next(this.numInFlightActivitiesSubject.value + 1);
                    try {
                        result = await output.activity.run(output.input);
                    }
                    finally {
                        this.numInFlightActivitiesSubject.next(this.numInFlightActivitiesSubject.value - 1);
                        group$.close();
                    }
                    const status = result.failed ? 'failed' : result.completed ? 'completed' : 'cancelled';
                    span.setAttributes({ status });
                    if (status === 'failed') {
                        // Make sure to flush the last heartbeat
                        this.log.trace('Activity failed, waiting for heartbeats to be flushed', {
                            ...(0, activity_log_interceptor_1.activityLogAttributes)(output.activity.info),
                            status,
                        });
                        await new Promise((resolve) => {
                            this.activityHeartbeatSubject.next({
                                type: 'completion',
                                flushRequired: true,
                                base64TaskToken,
                                callback: resolve,
                            });
                        });
                    }
                    else {
                        // Notify the Activity heartbeat state mapper that the Activity has completed
                        this.activityHeartbeatSubject.next({
                            type: 'completion',
                            flushRequired: false,
                            base64TaskToken,
                            callback: () => undefined,
                        });
                    }
                    this.log.trace('Activity resolved', {
                        ...(0, activity_log_interceptor_1.activityLogAttributes)(output.activity.info),
                        status,
                    });
                    return { taskToken, result, parentSpan: output.parentSpan };
                });
            }), (0, operators_1.filter)((result) => result !== undefined), (0, operators_1.map)(({ parentSpan, ...rest }) => ({
                completion: proto_1.coresdk.ActivityTaskCompletion.encodeDelimited(rest).finish(),
                parentSpan,
            })));
        }));
    }
    /**
     * Process Workflow activations
     */
    workflowOperator() {
        const { workflowCreator } = this;
        if (workflowCreator === undefined) {
            throw new common_1.IllegalStateError('Cannot process workflows without an IsolateContextProvider');
        }
        return (0, rxjs_1.pipe)((0, rxutils_1.closeableGroupBy)(({ activation }) => activation.runId), (0, operators_1.mergeMap)((group$) => {
            return (0, rxjs_1.merge)(group$.pipe((0, operators_1.map)((act) => ({ ...act, synthetic: false }))), this.workflowPollerStateSubject.pipe(
            // Core has indicated that it will not return any more poll results, evict all cached WFs
            (0, operators_1.filter)((state) => state !== 'POLLING'), (0, operators_1.first)(), (0, operators_1.map)(() => {
                return {
                    parentSpan: this.tracer.startSpan('workflow.shutdown.evict'),
                    activation: proto_1.coresdk.workflow_activation.WorkflowActivation.create({
                        runId: group$.key,
                        jobs: [{ removeFromCache: Worker.SELF_INDUCED_SHUTDOWN_EVICTION }],
                    }),
                    synthetic: true,
                };
            }), (0, operators_1.takeUntil)(group$.pipe((0, operators_1.last)(undefined, null))))).pipe((0, operators_1.tap)(() => {
                this.numInFlightActivationsSubject.next(this.numInFlightActivationsSubject.value + 1);
            }), (0, rxutils_1.mergeMapWithState)(async (state, { activation, parentSpan, synthetic }) => {
                try {
                    return await (0, tracing_1.instrument)(this.tracer, parentSpan, 'workflow.process', async (span) => {
                        span.setAttributes({
                            numInFlightActivations: this.numInFlightActivationsSubject.value,
                            numCachedWorkflows: this.numCachedWorkflowsSubject.value,
                        });
                        const removeFromCacheIx = activation.jobs.findIndex(({ removeFromCache }) => removeFromCache);
                        const close = removeFromCacheIx !== -1;
                        const jobs = activation.jobs;
                        if (close) {
                            const asEvictJob = jobs.splice(removeFromCacheIx, 1)[0].removeFromCache;
                            if (asEvictJob) {
                                this.evictionsEmitter.emit('eviction', {
                                    runId: activation.runId,
                                    evictJob: asEvictJob,
                                });
                            }
                        }
                        activation.jobs = jobs;
                        if (jobs.length === 0) {
                            this.log.trace('Disposing workflow', {
                                ...(state ? state.logAttributes : { runId: activation.runId }),
                            });
                            await state?.workflow.dispose();
                            if (!close) {
                                throw new common_1.IllegalStateError('Got a Workflow activation with no jobs');
                            }
                            const completion = synthetic
                                ? undefined
                                : proto_1.coresdk.workflow_completion.WorkflowActivationCompletion.encodeDelimited({
                                    runId: activation.runId,
                                    successful: {},
                                }).finish();
                            return { state: undefined, output: { close, completion, parentSpan } };
                        }
                        if (state === undefined) {
                            // Find a workflow start job in the activation jobs list
                            const maybeStartWorkflow = activation.jobs.find((j) => j.startWorkflow);
                            if (maybeStartWorkflow !== undefined) {
                                const startWorkflow = maybeStartWorkflow.startWorkflow;
                                if (!(startWorkflow &&
                                    startWorkflow.workflowId != null &&
                                    startWorkflow.workflowType != null &&
                                    startWorkflow.randomnessSeed != null &&
                                    startWorkflow.firstExecutionRunId != null &&
                                    startWorkflow.attempt != null &&
                                    startWorkflow.startTime != null)) {
                                    throw new TypeError(`Malformed StartWorkflow activation: ${JSON.stringify(maybeStartWorkflow)}`);
                                }
                                if (activation.timestamp == null) {
                                    throw new TypeError('Got activation with no timestamp, cannot create a new Workflow instance');
                                }
                                const { workflowId, randomnessSeed, workflowType, parentWorkflowInfo, workflowExecutionTimeout, workflowRunTimeout, workflowTaskTimeout, continuedFromExecutionRunId, continuedFailure, lastCompletionResult, firstExecutionRunId, retryPolicy, attempt, cronSchedule, workflowExecutionExpirationTime, cronScheduleToScheduleInterval, memo, searchAttributes, } = startWorkflow;
                                const workflowInfo = {
                                    workflowId,
                                    runId: activation.runId,
                                    workflowType,
                                    searchAttributes: (0, common_1.mapFromPayloads)(common_1.searchAttributePayloadConverter, searchAttributes?.indexedFields) || {},
                                    memo: await (0, internal_non_workflow_1.decodeMapFromPayloads)(this.options.loadedDataConverter, memo?.fields),
                                    parent: (0, utils_1.convertToParentWorkflowType)(parentWorkflowInfo),
                                    lastResult: await (0, internal_non_workflow_1.decodeFromPayloadsAtIndex)(this.options.loadedDataConverter, 0, lastCompletionResult?.payloads),
                                    lastFailure: await (0, internal_non_workflow_1.decodeOptionalFailureToOptionalError)(this.options.loadedDataConverter, continuedFailure),
                                    taskQueue: this.options.taskQueue,
                                    namespace: this.options.namespace,
                                    firstExecutionRunId,
                                    continuedFromExecutionRunId: continuedFromExecutionRunId || undefined,
                                    startTime: (0, time_1.tsToDate)(startWorkflow.startTime),
                                    runStartTime: (0, time_1.tsToDate)(activation.timestamp),
                                    executionTimeoutMs: (0, time_1.optionalTsToMs)(workflowExecutionTimeout),
                                    executionExpirationTime: (0, time_1.optionalTsToDate)(workflowExecutionExpirationTime),
                                    runTimeoutMs: (0, time_1.optionalTsToMs)(workflowRunTimeout),
                                    taskTimeoutMs: (0, time_1.tsToMs)(workflowTaskTimeout),
                                    retryPolicy: (0, common_1.decompileRetryPolicy)(retryPolicy),
                                    attempt,
                                    cronSchedule: cronSchedule || undefined,
                                    // 0 is the default, and not a valid value, since crons are at least a minute apart
                                    cronScheduleToScheduleInterval: (0, time_1.optionalTsToMs)(cronScheduleToScheduleInterval) || undefined,
                                    historyLength: activation.historyLength,
                                    // Exact truncation for multi-petabyte histories
                                    // A zero value means that it was not set by the server
                                    historySize: activation.historySizeBytes.toNumber(),
                                    continueAsNewSuggested: activation.continueAsNewSuggested,
                                    unsafe: {
                                        now: () => Date.now(),
                                        isReplaying: activation.isReplaying,
                                    },
                                };
                                const logAttributes = (0, workflow_log_interceptor_1.workflowLogAttributes)(workflowInfo);
                                this.log.trace('Creating workflow', logAttributes);
                                const patchJobs = activation.jobs.filter((j) => j.notifyHasPatch != null);
                                const patches = patchJobs.map(({ notifyHasPatch }) => {
                                    const { patchId } = notifyHasPatch;
                                    if (!patchId) {
                                        throw new TypeError('Got a patch without a patchId');
                                    }
                                    return patchId;
                                });
                                const workflow = await (0, tracing_1.instrument)(this.tracer, span, 'workflow.create', async () => {
                                    return await workflowCreator.createWorkflow({
                                        info: workflowInfo,
                                        randomnessSeed: randomnessSeed.toBytes(),
                                        now: (0, time_1.tsToMs)(activation.timestamp),
                                        patches,
                                        showStackTraceSources: this.options.showStackTraceSources,
                                    });
                                });
                                state = { workflow, logAttributes };
                                this.numCachedWorkflowsSubject.next(this.numCachedWorkflowsSubject.value + 1);
                            }
                            else {
                                throw new common_1.IllegalStateError('Received workflow activation for an untracked workflow with no start workflow job');
                            }
                        }
                        let isFatalError = false;
                        try {
                            const decodedActivation = await this.workflowCodecRunner.decodeActivation(activation);
                            const unencodedCompletion = await state.workflow.activate(decodedActivation);
                            const completion = await this.workflowCodecRunner.encodeCompletion(unencodedCompletion);
                            this.log.trace('Completed activation', state.logAttributes);
                            span.setAttribute('close', close);
                            return { state, output: { close, completion, parentSpan } };
                        }
                        catch (err) {
                            if (err instanceof core_bridge_1.UnexpectedError) {
                                isFatalError = true;
                            }
                            throw err;
                        }
                        finally {
                            // Fatal error means we cannot call into this workflow again unfortunately
                            if (!isFatalError) {
                                // When processing workflows through runReplayHistories, Core may still send non-replay
                                // activations on the very last Workflow Task in some cases. Though Core is technically exact
                                // here, the fact that sinks marked with callDuringReplay = false may get called on a replay
                                // worker is definitely a surprising behavior. For that reason, we extend the isReplaying flag in
                                // this case to also include anything running under in a replay worker.
                                const isReplaying = activation.isReplaying || this.isReplayWorker;
                                const calls = await state.workflow.getAndResetSinkCalls();
                                await this.processSinkCalls(calls, isReplaying);
                            }
                        }
                    });
                }
                catch (error) {
                    if (error instanceof core_bridge_1.UnexpectedError) {
                        // rethrow and fail the worker
                        throw error;
                    }
                    this.log.error('Failed to activate workflow', {
                        ...(state ? state.logAttributes : { runId: activation.runId }),
                        error,
                        workflowExists: state !== undefined,
                    });
                    const completion = proto_1.coresdk.workflow_completion.WorkflowActivationCompletion.encodeDelimited({
                        runId: activation.runId,
                        failed: {
                            failure: await (0, internal_non_workflow_1.encodeErrorToFailure)(this.options.loadedDataConverter, error),
                        },
                    }).finish();
                    // We do not dispose of the Workflow yet, wait to be evicted from Core.
                    // This is done to simplify the Workflow lifecycle so Core is the sole driver.
                    return { state: undefined, output: { close: true, completion, parentSpan } };
                }
            }, undefined), (0, operators_1.tap)(({ close }) => {
                this.numInFlightActivationsSubject.next(this.numInFlightActivationsSubject.value - 1);
                if (close) {
                    group$.close();
                    this.runIdsToSpanContext.delete(group$.key);
                    this.numCachedWorkflowsSubject.next(this.numCachedWorkflowsSubject.value - 1);
                }
            }), (0, operators_1.takeWhile)(({ close }) => !close, true /* inclusive */));
        }), (0, operators_1.map)(({ completion, parentSpan }) => ({ completion, parentSpan })), (0, operators_1.filter)((result) => result.completion !== undefined));
    }
    /**
     * Process extracted external calls from Workflow post activation.
     *
     * Each SinkCall is translated into a injected sink function call.
     *
     * This function does not throw, it will log in case of missing sinks
     * or failed sink function invocations.
     */
    async processSinkCalls(externalCalls, isReplaying) {
        const { sinks } = this.options;
        const filteredCalls = externalCalls
            // Map sink call to the corresponding sink function definition
            .map((call) => ({ call, sink: sinks?.[call.ifaceName]?.[call.fnName] }))
            // Reject calls to undefined sink definitions
            .filter(({ call: { ifaceName, fnName }, sink }) => {
            if (sink !== undefined)
                return true;
            this.log.error('Workflow referenced an unregistered external sink', {
                ifaceName,
                fnName,
            });
            return false;
        })
            // If appropriate, reject calls to sink functions not configured with `callDuringReplay = true`
            .filter(({ sink }) => sink?.callDuringReplay || !isReplaying);
        // Make a wrapper function, to make things easier afterward
        await Promise.all(filteredCalls.map(async ({ call, sink }) => {
            try {
                await sink?.fn(call.workflowInfo, ...call.args);
            }
            catch (error) {
                this.log.error('External sink function threw an error', {
                    ifaceName: call.ifaceName,
                    fnName: call.fnName,
                    error,
                    workflowInfo: call.workflowInfo,
                });
            }
        }));
    }
    /**
     * Listen on heartbeats emitted from activities and send them to core.
     * Errors from core responses are translated to cancellation requests and fed back via the activityFeedbackSubject.
     */
    activityHeartbeat$() {
        function process(state, heartbeat) {
            return { state: { ...state, processing: true, pending: undefined }, output: { type: 'send', heartbeat } };
        }
        function storePending(state, heartbeat) {
            return { state: { ...state, pending: heartbeat }, output: null };
        }
        function complete(callback) {
            return {
                state: { pending: undefined, completionCallback: undefined, processing: false, closed: true },
                output: { type: 'close', completionCallback: callback },
            };
        }
        return this.activityHeartbeatSubject.pipe(
        // The only way for this observable to be closed is by state changing to DRAINED meaning that all in-flight activities have been resolved and thus there should not be any heartbeats to send.
        this.takeUntilState('DRAINED'), (0, operators_1.tap)({
            complete: () => this.log.debug('Heartbeats complete'),
        }), (0, rxutils_1.closeableGroupBy)(({ base64TaskToken }) => base64TaskToken), (0, operators_1.mergeMap)((group$) => group$.pipe((0, rxutils_1.mapWithState)((state, input) => {
            if (input.type === 'create') {
                this.numHeartbeatingActivitiesSubject.next(this.numHeartbeatingActivitiesSubject.value + 1);
                return { state: { processing: false, closed: false }, output: null };
            }
            // Ignore any input if we've marked this activity heartbeat stream as closed
            // (rogue heartbeat)
            if (state.closed)
                return { state, output: { type: 'close' } };
            switch (input.type) {
                case 'heartbeat':
                    this.log.trace('Got activity heartbeat', (0, activity_log_interceptor_1.activityLogAttributes)(input.info));
                    if (state.processing) {
                        // We're already processing a heartbeat, mark this one as pending
                        return storePending(state, input);
                    }
                    else {
                        // Ready to send heartbeat, mark that we're now processing
                        return process(state, input);
                    }
                case 'flush':
                    if (state.pending) {
                        // Send pending heartbeat
                        return process(state, state.pending);
                    }
                    else if (state.completionCallback) {
                        // We were asked to complete, fulfill that request
                        return complete(state.completionCallback);
                    }
                    else {
                        // Nothing to do, wait for completion or heartbeat
                        return { state: { ...state, processing: false }, output: null };
                    }
                case 'completion':
                    if (state.processing) {
                        // Store the completion callback until heartbeat has been flushed
                        return {
                            state: {
                                ...state,
                                // If flush isn't required, delete any pending heartbeat
                                pending: input.flushRequired ? state.pending : undefined,
                                completionCallback: input.callback,
                            },
                            output: null,
                        };
                    }
                    else if (!input.flushRequired) {
                        return complete(input.callback);
                    }
                    else {
                        if (state.pending) {
                            // Flush the final heartbeat and store the completion callback
                            return process({ ...state, completionCallback: input.callback }, state.pending);
                        }
                        else {
                            // Nothing to flush, complete and call back
                            return complete(input.callback);
                        }
                    }
            }
        }, 
        // Start `closed`, wait for a `create` input to open the stream.
        // This prevents rogue activities from heartbeating and keeping
        // this stream open.
        { processing: false, closed: true }), (0, operators_1.filter)((out) => out != null), (0, operators_1.tap)((out) => {
            if (out.type === 'close') {
                this.numHeartbeatingActivitiesSubject.next(this.numHeartbeatingActivitiesSubject.value - 1);
                out.completionCallback?.();
            }
        }), (0, operators_1.takeWhile)((out) => out.type !== 'close'), (0, operators_1.mergeMap)(async ({ heartbeat: { base64TaskToken, taskToken, details, onError, info } }) => {
            let payload;
            try {
                try {
                    payload = await (0, internal_non_workflow_1.encodeToPayload)(this.options.loadedDataConverter, details);
                }
                catch (error) {
                    this.log.warn('Failed to encode heartbeat details, cancelling Activity', {
                        error,
                        ...(0, activity_log_interceptor_1.activityLogAttributes)(info),
                    });
                    onError();
                    return;
                }
                const arr = proto_1.coresdk.ActivityHeartbeat.encodeDelimited({
                    taskToken,
                    details: [payload],
                }).finish();
                this.nativeWorker.recordActivityHeartbeat((0, utils_1.byteArrayToBuffer)(arr));
            }
            finally {
                this.activityHeartbeatSubject.next({ type: 'flush', base64TaskToken });
            }
        }), (0, operators_1.tap)({ complete: group$.close }))));
    }
    /**
     * Poll core for `WorkflowActivation`s while respecting worker state.
     */
    workflowPoll$() {
        return this.pollLoop$(async () => {
            const parentSpan = this.tracer.startSpan('workflow.activation');
            return await (0, tracing_1.instrument)(this.tracer, parentSpan, 'workflow.poll', async (span) => {
                this.hasOutstandingWorkflowPoll = true;
                let buffer;
                try {
                    buffer = await this.nativeWorker.pollWorkflowActivation(span.spanContext());
                }
                finally {
                    this.hasOutstandingWorkflowPoll = false;
                }
                const activation = proto_1.coresdk.workflow_activation.WorkflowActivation.decode(new Uint8Array(buffer));
                const { runId, ...rest } = activation;
                this.log.trace('Got workflow activation', activation);
                span.setAttribute(otel_1.RUN_ID_ATTR_KEY, runId).setAttribute(otel_1.NUM_JOBS_ATTR_KEY, rest.jobs.length);
                await this.linkWorkflowSpans(runId, rest.jobs, parentSpan);
                return { activation, parentSpan };
            }, (err) => err instanceof core_bridge_1.ShutdownError);
        }).pipe((0, operators_1.tap)({
            complete: () => {
                this.workflowPollerStateSubject.next('SHUTDOWN');
            },
            error: () => {
                this.workflowPollerStateSubject.next('FAILED');
            },
        }));
    }
    /**
     * Given a run ID, some jobs from a new WFT, and the parent span or the workflow activation,
     * handle linking any span context that exists in the WF headers to our internal spans.
     *
     * The result here is that our SDK spans in node and core are separate from the user's spans
     * that they create when they use interceptors, with our spans being linked to theirs.
     *
     * If the activation includes WF start, headers will be extracted and cached. If it does not,
     * any previously such extracted header will be used for the run.
     */
    async linkWorkflowSpans(runId, jobs, parentSpan) {
        let linkedContext = this.runIdsToSpanContext.get(runId);
        // If there is an otel context in the headers, link our trace for the workflow to the
        // trace in the header.
        for (const j of jobs) {
            if (j.startWorkflow != null) {
                const ctx = await (0, otel_1.extractSpanContextFromHeaders)(j.startWorkflow.headers ?? {});
                if (ctx !== undefined && linkedContext === undefined) {
                    this.runIdsToSpanContext.set(runId, ctx);
                    linkedContext = ctx;
                }
            }
        }
        if (linkedContext != null) {
            (0, otel_1.linkSpans)(parentSpan, linkedContext);
        }
    }
    /**
     * Poll for Workflow activations, handle them, and report completions.
     */
    workflow$() {
        // This Worker did not register any workflows, return early
        if (this.workflowCreator === undefined) {
            this.log.warn('No workflows registered, not polling for workflow tasks');
            this.workflowPollerStateSubject.next('SHUTDOWN');
            return rxjs_1.EMPTY;
        }
        return this.workflowPoll$().pipe(this.workflowOperator(), (0, operators_1.mergeMap)(async ({ completion, parentSpan: root }) => {
            const span = (0, tracing_1.childSpan)(this.tracer, root, 'workflow.complete');
            try {
                await this.nativeWorker.completeWorkflowActivation(span.spanContext(), completion.buffer.slice(completion.byteOffset));
                span.setStatus({ code: otel.SpanStatusCode.OK });
            }
            catch (err) {
                span.setStatus({ code: otel.SpanStatusCode.ERROR, message: (0, type_helpers_1.errorMessage)(err) });
                throw err;
            }
            finally {
                span.end();
                root.end();
            }
        }), (0, operators_1.tap)({
            complete: () => {
                this.log.debug('Workflows complete');
            },
        }));
    }
    /**
     * Poll core for `ActivityTask`s while respecting worker state
     */
    activityPoll$() {
        return this.pollLoop$(async () => {
            const parentSpan = this.tracer.startSpan('activity.task');
            return await (0, tracing_1.instrument)(this.tracer, parentSpan, 'activity.poll', async (span) => {
                this.hasOutstandingActivityPoll = true;
                let buffer;
                try {
                    buffer = await this.nativeWorker.pollActivityTask(span.spanContext());
                }
                finally {
                    this.hasOutstandingActivityPoll = false;
                }
                const task = proto_1.coresdk.activity_task.ActivityTask.decode(new Uint8Array(buffer));
                const { taskToken, ...rest } = task;
                const base64TaskToken = formatTaskToken(taskToken);
                this.log.trace('Got activity task', { taskToken: base64TaskToken, ...rest });
                const { variant } = task;
                if (variant === undefined) {
                    throw new TypeError('Got an activity task without a "variant" attribute');
                }
                parentSpan.setAttributes({
                    [otel_1.TASK_TOKEN_ATTR_KEY]: base64TaskToken,
                    variant,
                    [otel_1.RUN_ID_ATTR_KEY]: task.start?.workflowExecution?.runId ?? 'unknown',
                });
                // If the activity had otel headers, link to that span
                if (task.start?.headerFields) {
                    const ctx = await (0, otel_1.extractSpanContextFromHeaders)(task.start.headerFields);
                    (0, otel_1.linkSpans)(parentSpan, ctx);
                }
                return { task, parentSpan, base64TaskToken };
            }, (err) => err instanceof core_bridge_1.ShutdownError);
        }).pipe((0, operators_1.tap)({
            complete: () => {
                this.activityPollerStateSubject.next('SHUTDOWN');
            },
            error: () => {
                this.activityPollerStateSubject.next('FAILED');
            },
        }));
    }
    activity$() {
        // This Worker did not register any activities, return early
        if (this.options.activities === undefined || Object.keys(this.options.activities).length === 0) {
            if (!this.isReplayWorker)
                this.log.warn('No activities registered, not polling for activity tasks');
            this.activityPollerStateSubject.next('SHUTDOWN');
            return rxjs_1.EMPTY;
        }
        return this.activityPoll$().pipe(this.activityOperator(), (0, operators_1.mergeMap)(async ({ completion, parentSpan }) => {
            try {
                await (0, tracing_1.instrument)(this.tracer, parentSpan, 'activity.complete', () => this.nativeWorker.completeActivityTask(parentSpan.spanContext(), completion.buffer.slice(completion.byteOffset)));
            }
            finally {
                parentSpan.end();
            }
        }), (0, operators_1.tap)({ complete: () => this.log.debug('Activities complete') }));
    }
    takeUntilState(state) {
        return (0, operators_1.takeUntil)(this.stateSubject.pipe((0, operators_1.filter)((value) => value === state)));
    }
    /**
     * Run the Worker until `fnOrPromise` completes. Then {@link shutdown} and wait for {@link run} to complete.
     *
     * @returns the result of `fnOrPromise`
     *
     * Throws on fatal Worker errors.
     *
     * **SDK versions `< 1.5.0`**:
     * This method would not wait for worker to complete shutdown if the inner `fnOrPromise` threw an error.
     *
     * **SDK versions `>=1.5.0`**:
     * This method always waits for both worker shutdown and inner `fnOrPromise` to resolve.
     * If one of worker run -or- the inner promise throw an error, that error is rethrown.
     * If both throw an error, a {@link CombinedWorkerRunError} with a `cause` attribute containing both errors.
     */
    async runUntil(fnOrPromise) {
        const workerRunPromise = this.run();
        const innerPromise = (async () => {
            try {
                const p = typeof fnOrPromise === 'function' ? fnOrPromise() : fnOrPromise;
                return await p;
            }
            finally {
                if (this.state === 'RUNNING') {
                    this.shutdown();
                }
            }
        })();
        const [innerResult, workerRunResult] = await Promise.allSettled([innerPromise, workerRunPromise]);
        if (workerRunResult.status === 'rejected') {
            if (innerResult.status === 'rejected') {
                throw new CombinedWorkerRunError('Worker terminated with fatal error in `runUntil`', {
                    cause: {
                        workerError: workerRunResult.reason,
                        innerError: innerResult.reason,
                    },
                });
            }
            else {
                throw workerRunResult.reason;
            }
        }
        else if (innerResult.status === 'rejected') {
            throw innerResult.reason;
        }
        else {
            return innerResult.value;
        }
    }
    /**
     * Start polling on the Task Queue for tasks. Completes after graceful {@link shutdown}, once the Worker reaches the
     * `'STOPPED'` state.
     *
     * Throws on a fatal error or failure to shutdown gracefully.
     *
     * @see {@link errors}
     *
     * To stop polling, call {@link shutdown} or send one of {@link Runtime.options.shutdownSignals}.
     */
    async run() {
        if (this.state !== 'INITIALIZED') {
            throw new common_1.IllegalStateError('Poller was already started');
        }
        this.state = 'RUNNING';
        const shutdownCallback = () => this.shutdown();
        runtime_1.Runtime.instance().registerShutdownSignalCallback(shutdownCallback);
        try {
            try {
                await (0, rxjs_1.lastValueFrom)((0, rxjs_1.merge)(this.unexpectedErrorSubject.pipe((0, operators_1.takeUntil)(this.stateSubject.pipe((0, operators_1.filter)((st) => st === 'DRAINED')))), this.forceShutdown$(), this.activityHeartbeat$(), (0, rxjs_1.merge)(this.workflow$(), this.activity$()).pipe((0, operators_1.tap)({
                    complete: () => {
                        this.state = 'DRAINED';
                    },
                }))).pipe((0, operators_1.tap)({
                    complete: () => {
                        this.state = 'STOPPED';
                    },
                    error: (error) => {
                        this.log.error('Worker failed', { error });
                        this.state = 'FAILED';
                    },
                })), { defaultValue: undefined });
            }
            finally {
                runtime_1.Runtime.instance().deregisterShutdownSignalCallback(shutdownCallback);
            }
            // Only shutdown the native worker if we completed without an error.
            // Otherwise Rust / TS are in an unknown state and shutdown might hang.
            // A new process must be created in order to instantiate a new Rust Core.
            // TODO: force shutdown in core?
            await this.nativeWorker.finalizeShutdown();
        }
        finally {
            try {
                // Only exists in non-replay Worker
                if (this.connection) {
                    (0, connection_1.extractReferenceHolders)(this.connection).delete(this.nativeWorker);
                    // Only close if this worker is the creator of the connection
                    if (this.connection instanceof connection_1.InternalNativeConnection) {
                        await this.connection.close();
                    }
                }
                await this.workflowCreator?.destroy();
            }
            finally {
                this.nativeWorker.flushCoreLogs();
            }
        }
    }
}
exports.Worker = Worker;
Worker.nativeWorkerCtor = NativeWorker;
// Used to add uniqueness to replay worker task queue names
Worker.replayWorkerCount = 0;
Worker.SELF_INDUCED_SHUTDOWN_EVICTION = {
    message: 'Shutting down',
    reason: replay_1.EvictionReason.FATAL,
};
function parseWorkflowCode(code, codePath) {
    const [actualCode, sourceMapJson] = extractSourceMap(code);
    const sourceMap = JSON.parse(sourceMapJson);
    // JS debuggers (at least VSCode's) have a few requirements regarding the script and its source map, notably:
    // - The script file name's must look like an absolute path (relative paths are treated as node internals scripts)
    // - If the script contains a sourceMapURL directive, the executable 'file' indicated by the source map must match the
    //   filename of the script itself. If the source map's file is a relative path, then it gets resolved relative to cwd
    const filename = path.resolve(process.cwd(), codePath ?? sourceMap.file);
    if (filename !== codePath) {
        sourceMap.file = filename;
        const patchedSourceMapJson = Buffer.from(JSON.stringify(sourceMap)).toString('base64');
        const fixedSourceMappingUrl = `\n//# sourceMappingURL=data:application/json;base64,${patchedSourceMapJson}`;
        code = actualCode + fixedSourceMappingUrl;
    }
    // Preloading the script makes breakpoints significantly more reliable and more responsive
    let script = new vm.Script(code, { filename });
    let context = vm.createContext({});
    try {
        script.runInContext(context);
    }
    catch (e) {
        // Context has not been properly configured, so eventual errors are possible. Just ignore at this point
    }
    // Keep these objects from GC long enough for debugger to complete parsing the source map and reporting locations
    // to the node process. Otherwise, the debugger risks source mapping resolution errors, meaning breakpoints wont work.
    setTimeout(() => {
        script = undefined;
        context = undefined;
    }, 10000);
    return { code, sourceMap, filename };
}
exports.parseWorkflowCode = parseWorkflowCode;
function extractSourceMap(code) {
    const sourceMapCommentPos = code.lastIndexOf('//# sourceMappingURL=data:');
    if (sourceMapCommentPos > 0) {
        const base64TagIndex = code.indexOf('base64,', sourceMapCommentPos);
        if (base64TagIndex > 0) {
            const sourceMapJson = Buffer.from(code.slice(base64TagIndex + 'base64,'.length).trimEnd(), 'base64').toString();
            const actualCode = code.slice(0, sourceMapCommentPos);
            return [actualCode, sourceMapJson];
        }
    }
    throw new Error("Can't extract inlined source map from the provided Workflow Bundle");
}
/**
 * Transform an ActivityTask into ActivityInfo to pass on into an Activity
 */
async function extractActivityInfo(task, dataConverter, activityNamespace, taskQueue) {
    // NOTE: We trust core to supply all of these fields instead of checking for null and undefined everywhere
    const { taskToken } = task;
    const start = task.start;
    const activityId = start.activityId;
    return {
        taskToken,
        taskQueue,
        base64TaskToken: formatTaskToken(taskToken),
        activityId,
        workflowExecution: start.workflowExecution,
        attempt: start.attempt,
        isLocal: start.isLocal,
        activityType: start.activityType,
        workflowType: start.workflowType,
        heartbeatTimeoutMs: start.heartbeatTimeout ? (0, time_1.tsToMs)(start.heartbeatTimeout) : undefined,
        heartbeatDetails: await (0, internal_non_workflow_1.decodeFromPayloadsAtIndex)(dataConverter, 0, start.heartbeatDetails),
        activityNamespace,
        workflowNamespace: start.workflowNamespace,
        scheduledTimestampMs: (0, time_1.tsToMs)(start.scheduledTime),
        startToCloseTimeoutMs: (0, time_1.tsToMs)(start.startToCloseTimeout),
        scheduleToCloseTimeoutMs: (0, time_1.tsToMs)(start.scheduleToCloseTimeout),
        currentAttemptScheduledTimestampMs: (0, time_1.tsToMs)(start.currentAttemptScheduledTime),
    };
}
//# sourceMappingURL=worker.js.map