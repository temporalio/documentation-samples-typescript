"use strict";
/**
 * This package's main export is {@link Context}. Get the current Activity's context with
 * {@link Context.current | `Context.current()`}:
 *
 * ```ts
 * import { Context } from '@temporalio/activity';
 *
 * export async function myActivity() {
 *   const context = Context.current();
 * }
 * ```
 *
 * Any function can be used as an Activity as long as its parameters and return value are serializable using a
 * {@link https://docs.temporal.io/concepts/what-is-a-data-converter/ | DataConverter}.
 *
 * ### Cancellation
 *
 * Activity Cancellation:
 *
 * - lets the Activity know it doesn't need to keep doing work, and
 * - gives the Activity time to clean up any resources it has created.
 *
 * Activities can only receive Cancellation if they {@link Context.heartbeat | emit heartbeats} or are Local Activities
 * (which can't heartbeat but receive Cancellation anyway).
 *
 * An Activity may receive Cancellation if:
 *
 * - The Workflow scope containing the Activity call was requested to be Cancelled and
 *   {@link ActivityOptions.cancellationType} was **not** set to {@link ActivityCancellationType.ABANDON}. The scope can
 *   be cancelled in either of the following ways:
 *   - The entire Workflow was Cancelled (via {@link WorkflowHandle.cancel}).
 *   - Calling {@link CancellationScope.cancel}) from inside a Workflow.
 * - The Worker has started to shut down. Shutdown is initiated by either:
 *   - One of the {@link RuntimeOptions.shutdownSignals} was sent to the process.
 *   - {@link Worker.shutdown | `Worker.shutdown()`} was called.
 * - The Activity was considered failed by the Server because any of the Activity timeouts have triggered (for example,
 *   the Server didn't receive a heartbeat within the {@link ActivityOptions.heartbeatTimeout}). The
 *   {@link CancelledFailure} will have `message: 'TIMED_OUT'`.
 * - An Activity sends a heartbeat with `Context.current().heartbeat()` and the heartbeat details can't be converted by
 *   the Worker's configured {@link DataConverter}.
 * - The Workflow Run reached a {@link https://docs.temporal.io/workflows#status | Closed state}, in which case the
 *   {@link CancelledFailure} will have `message: 'NOT_FOUND'`.
 *
 * The reason for the Cancellation is available at {@link CancelledFailure.message} or
 * {@link Context#cancellationSignal | Context.cancellationSignal.reason}.
 *
 * Activity implementations should opt-in and subscribe to cancellation using one of the following methods:
 *
 * 1. `await` on {@link Context.cancelled | `Context.current().cancelled`} or
 *    {@link Context.sleep | `Context.current().sleep()`}, which each throw a {@link CancelledFailure}.
 * 1. Pass the context's {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal | `AbortSignal`} at
 *    {@link Context.cancellationSignal | `Context.current().cancellationSignal`} to a library that supports it.
 *
 * ### Examples
 *
 * #### An Activity that sends progress heartbeats and can be Cancelled
 *
 * <!--SNIPSTART typescript-activity-fake-progress-->
 * <!--SNIPEND-->
 *
 * #### An Activity that makes a cancellable HTTP request
 *
 * It passes the `AbortSignal` to {@link https://github.com/node-fetch/node-fetch#api | `fetch`}: `fetch(url, { signal:
 * Context.current().cancellationSignal })`.
 *
 * <!--SNIPSTART typescript-activity-cancellable-fetch-->
 * <!--SNIPEND-->
 *
 * @module
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Context = exports.asyncLocalStorage = exports.CompleteAsyncError = exports.CancelledFailure = exports.ApplicationFailure = void 0;
require("abort-controller/polyfill"); // eslint-disable-line import/no-unassigned-import
const node_async_hooks_1 = require("node:async_hooks");
const time_1 = require("@temporalio/common/lib/time");
const type_helpers_1 = require("@temporalio/common/lib/type-helpers");
var common_1 = require("@temporalio/common");
Object.defineProperty(exports, "ApplicationFailure", { enumerable: true, get: function () { return common_1.ApplicationFailure; } });
Object.defineProperty(exports, "CancelledFailure", { enumerable: true, get: function () { return common_1.CancelledFailure; } });
/**
 * Throw this error from an Activity in order to make the Worker forget about this Activity.
 *
 * The Activity can then be completed asynchronously (from anywhereâ€”usually outside the Worker) using
 * {@link Client.activity}.
 *
 * @example
 *
 *```ts
 *import { CompleteAsyncError } from '@temporalio/activity';
 *
 *export async function myActivity(): Promise<never> {
 *  // ...
 *  throw new CompleteAsyncError();
 *}
 *```
 */
let CompleteAsyncError = class CompleteAsyncError extends Error {
};
CompleteAsyncError = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('CompleteAsyncError')
], CompleteAsyncError);
exports.CompleteAsyncError = CompleteAsyncError;
// Make it safe to use @temporalio/activity with multiple versions installed.
const asyncLocalStorageSymbol = Symbol.for('__temporal_activity_context_storage__');
if (!globalThis[asyncLocalStorageSymbol]) {
    globalThis[asyncLocalStorageSymbol] = new node_async_hooks_1.AsyncLocalStorage();
}
exports.asyncLocalStorage = globalThis[asyncLocalStorageSymbol];
/**
 * Activity Context, used to:
 *
 * - Get {@link Info} about the current Activity Execution
 * - Send {@link https://docs.temporal.io/concepts/what-is-an-activity-heartbeat | heartbeats}
 * - Get notified of Activity cancellation
 * - Sleep (cancellation-aware)
 *
 * Call `Context.current()` from Activity code in order to get the current Activity's Context.
 */
class Context {
    /**
     * **Not** meant to instantiated by Activity code, used by the worker.
     *
     * @ignore
     */
    constructor(info, cancelled, cancellationSignal, heartbeat, logger) {
        this.info = info;
        this.cancelled = cancelled;
        this.cancellationSignal = cancellationSignal;
        this.heartbeatFn = heartbeat;
        this.log = logger;
    }
    /**
     * Send a {@link https://docs.temporal.io/concepts/what-is-an-activity-heartbeat | heartbeat} from an Activity.
     *
     * If an Activity times out, then during the next retry, the last value of `details` is available at
     * {@link Info.heartbeatDetails}. This acts as a periodic checkpoint mechanism for the progress of an Activity.
     *
     * If an Activity times out on the final retry (relevant in cases in which {@link RetryPolicy.maximumAttempts} is
     * set), the Activity function call in the Workflow code will throw an {@link ActivityFailure} with the `cause`
     * attribute set to a {@link TimeoutFailure}, which has the last value of `details` available at
     * {@link TimeoutFailure.lastHeartbeatDetails}.
     *
     * Calling `heartbeat()` from a Local Activity has no effect.
     *
     * The SDK automatically throttles heartbeat calls to the server with a duration of 80% of the specified activity
     * heartbeat timeout. Throttling behavior may be customized with the `{@link maxHeartbeatThrottleInterval | https://typescript.temporal.io/api/interfaces/worker.WorkerOptions#maxheartbeatthrottleinterval} and {@link defaultHeartbeatThrottleInterval | https://typescript.temporal.io/api/interfaces/worker.WorkerOptions#defaultheartbeatthrottleinterval} worker options.
     *
     * Activities must heartbeat in order to receive Cancellation (unless they're Local Activities, which don't need to).
     *
     * :warning: Cancellation is not propagated from this function, use {@link cancelled} or {@link cancellationSignal} to
     * subscribe to cancellation notifications.
     */
    heartbeat(details) {
        this.heartbeatFn(details);
    }
    /**
     * Gets the context of the current Activity.
     *
     * Uses {@link https://nodejs.org/docs/latest-v14.x/api/async_hooks.html#async_hooks_class_asynclocalstorage | AsyncLocalStorage} under the hood to make it accessible in nested callbacks and promises.
     */
    static current() {
        const store = exports.asyncLocalStorage.getStore();
        if (store === undefined) {
            throw new Error('Activity context not initialized');
        }
        return store;
    }
    /**
     * Helper function for sleeping in an Activity.
     * @param ms Sleep duration: number of milliseconds or {@link https://www.npmjs.com/package/ms | ms-formatted string}
     * @returns A Promise that either resolves when `ms` is reached or rejects when the Activity is cancelled
     */
    sleep(ms) {
        let handle;
        const timer = new Promise((resolve) => {
            handle = setTimeout(resolve, (0, time_1.msToNumber)(ms));
        });
        return Promise.race([this.cancelled.finally(() => clearTimeout(handle)), timer]);
    }
}
exports.Context = Context;
//# sourceMappingURL=index.js.map